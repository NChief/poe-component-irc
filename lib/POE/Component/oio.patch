Index: IRC.pm
===================================================================
--- IRC.pm	(revision 296)
+++ IRC.pm	(working copy)
@@ -35,6 +35,68 @@
 $VERSION = '5.23';
 $REVISION = do {my@r=(q$Revision$=~/\d+/g);sprintf"%d"."%04d"x$#r,@r};
 
+use Object::InsideOut;
+
+my @IRC_CMDS :Field :Acc(IRC_CMDS);
+my @OBJECT_STATES_ARRAYREF :Field :Acc(OBJECT_STATES_ARRAYREF);
+my @OBJECT_STATES_HASHREF :Field :Acc(OBJECT_STATES_HASHREF);
+my @socket :Field :Acc(socket);
+
+my @dont_flood    :Field :Acc(dont_flood);
+my @raw_events    :Field :Acc(raw_events);
+my @mydns         :Field :Acc(mydns);
+my @connected     :Field :Acc(connected);
+my @send_queue    :Field :Acc(_send_queue);
+my @send_time     :Field :Acc(send_time);
+my @socketfactory :Field :Acc(socketfactory);
+my @alias         :Field :Acc(alias);
+my @ircd_compat   :Field :Acc(ircd_compat);
+my @srv_filter    :Field :Acc(srv_filter);
+my @out_filter    :Field :Acc(out_filter);
+my @can_do_zlib   :Field :Acc(can_do_zlib);
+my @isupport      :Field :Acc(_isupport);
+my @type          :Field :Acc(type);
+my @file          :Field :Acc(file);
+my @sock          :Field :Acc(sock);
+my @uplink        :Field :Acc(uplink);
+my @downlink      :Field :Acc(downlink);
+my @PLUGINS       :Field :Acc(PLUGINS);
+
+my @password     :Field :Acc(password)     :Arg(Name => 'password', Default => undef);
+my @localaddr    :Field :Acc(localaddr)    :Arg(Name => 'localaddr', Default => undef);
+my @localport    :Field :Acc(localport)    :Arg(Name => 'localport', Default => undef);
+my @nick         :Field :Acc(nick)         :Arg(Name => 'nick', Default => undef);
+my @port         :Field :Acc(port)         :Arg(Name => 'port', Default => undef);
+my @server       :Field :Acc(server)       :Arg(Name => 'server', Default => undef);
+my @proxy        :Field :Acc(proxy)        :Arg(Name => 'proxy', Default => undef);
+my @proxyport    :Field :Acc(proxyport)    :Arg(Name => 'proxyport', Default => undef);
+my @ircname      :Field :Acc(ircname)      :Arg(Name => 'ircname', Default => undef);
+my @username     :Field :Acc(username)     :Arg(Name => 'username', Default => undef);
+my @NoDNS        :Field :Acc(NoDNS)        :Arg(Name => 'NoDNS', Default => undef);
+my @nat_addr     :Field :Acc(nat_addr)     :Arg(Name => 'nat_addr', Default => undef);
+my @user_bitmode :Field :Acc(user_bitmode) :Arg(Name => 'user_bitmode', Default => undef);
+my @compress     :Field :Acc(compress)     :Arg(Name => 'compress', Default => undef);
+my @socks_proxy  :Field :Acc(socks_proxy)  :Arg(Name => 'socks_proxy', Default => undef);
+my @socks_port   :Field :Acc(socks_port)   :Arg(Name => 'socks_port', Default => undef);
+my @socks_id     :Field :Acc(socks_id)     :Arg(Name => 'socks_id', Default => undef);
+my @debug        :Field :Acc(_debug)       :Arg(Name => 'debug', Default => undef);
+my @ircd_filter  :Field :Acc(ircd_filter)  :Arg(Name => 'ircd_filter', Default => undef);
+my @ctcp_filter  :Field :Acc(ctcp_filter)  :Arg(Name => 'ctcp_filter', Default => undef);
+my @plugin_debug :Field :Acc(plugin_debug) :Arg(Name => 'plugin_debug', Default => undef);
+my @resolver     :Field :Acc(resolver)     :Arg(Name => 'resolver', Default => undef);
+my @UseSSL       :Field :Acc(UseSSL)       :Arg(Name => 'UseSSL', Default => undef);
+my @dcc_bind_port :Field :Acc(dcc_bind_port) :Arg(Name => 'dcc_bind_port', Default => undef);
+
+my @SESSION_ID :Field :Acc(SESSION_ID);
+my @INFO       :Field :Acc(INFO);
+my @dcc        :Field :Acc(_dcc);
+my @wheelmap   :Field :Acc(wheelmap);
+my @RealNick   :Field :Acc(RealNick);
+my @events     :Field :Acc(events);
+my @sessions   :Field :Acc(sessions);
+my @_shutdown  :Field :Acc(_shutdown);
+my @res_addresses :Field :Acc(res_addresses);
+
 # BINGOS: I have bundled up all the stuff that needs changing for inherited classes
 # 	  into _create. This gets called from 'spawn'.
 #	  $self->{OBJECT_STATES_ARRAYREF} contains event mappings to methods that have
@@ -71,9 +133,11 @@
 sub _create {
   my $self = shift;
 
-  $self->{IRC_CMDS} =
-  { 'rehash'    => [ PRI_HIGH,   'noargs',        ],
-    'die'	=> [ PRI_HIGH,	 'noargs',	  ],
+  $self->set(\@dcc, { });
+
+  $self->set(\@IRC_CMDS, {
+    'rehash'    => [ PRI_HIGH,   'noargs',        ],
+    'die'	    => [ PRI_HIGH,	 'noargs',	  ],
     'restart'   => [ PRI_HIGH,   'noargs',        ],
     'quit'      => [ PRI_NORMAL, 'oneoptarg',     ],
     'version'   => [ PRI_HIGH,   'oneoptarg',     ],
@@ -115,11 +179,11 @@
     'ctcpreply' => [ PRI_HIGH,   'ctcp',          ],
     'ping'      => [ PRI_HIGH,   'oneortwo',      ],
     'pong'      => [ PRI_HIGH,   'oneortwo',      ],
-  };
+  });
 
-  my @event_map = map {($_, $self->{IRC_CMDS}->{$_}->[CMD_SUB])} keys %{ $self->{IRC_CMDS} };
+  my @event_map = map {($_, $self->IRC_CMDS()->{$_}->[CMD_SUB])} keys %{ $self->IRC_CMDS() };
 
-  $self->{OBJECT_STATES_ARRAYREF} = [qw( _dcc_failed
+  $self->set(\@OBJECT_STATES_ARRAYREF, [qw( _dcc_failed
 				      _dcc_read
 				      _dcc_timeout
 				      _dcc_up
@@ -156,9 +220,12 @@
 				      sl_prioritized
 				      topic
 				      unregister
-				      userhost )];
+				      userhost )]);
 
-  $self->{OBJECT_STATES_HASHREF} = { @event_map, '_tryclose' => 'dcc_close', 'quote' => 'sl' };
+  $self->set(\@OBJECT_STATES_HASHREF, { @event_map, '_tryclose' => 'dcc_close', 'quote' => 'sl' });
+  
+  $self->set(\@wheelmap, { });
+  $self->set(\@dcc, { });
 
   return 1;
 }
@@ -175,49 +242,49 @@
     my %arg = %$args;
 
     if (exists $arg{'flood'} and $arg{'flood'}) {
-      $self->{'dont_flood'} = 0;
+      $self->dont_flood(0);
     } else {
-      $self->{'dont_flood'} = 1 unless( defined ( $self->{'dont_flood'} ) and $self->{'dont_flood'} eq '0' );
+      $self->dont_flood(1) unless( defined ( $self->dont_flood ) and $self->dont_flood() eq '0' );
     }
 
     if (exists $arg{'raw'} and $arg{'raw'}) {
-      $self->{'raw_events'} = 1;
+      $self->raw_events(1);
     } else {
-      $self->{'raw_events'} = 0 unless ( $self->{'raw_events'} );
+      $self->raw_events(0) unless ( $self->raw_events() );
     }
 
-    $self->{'password'} = $arg{'password'} if exists $arg{'password'};
-    $self->{'localaddr'} = $arg{'localaddr'} if exists $arg{'localaddr'};
-    $self->{'localport'} = $arg{'localport'} if exists $arg{'localport'};
-    $self->{'nick'} = $arg{'nick'} if exists $arg{'nick'};
-    $self->{'port'} = $arg{'port'} if exists $arg{'port'};
-    $self->{'server'} = $arg{'server'} if exists $arg{'server'};
-    $self->{'proxy'} = $arg{'proxy'} if exists $arg{'proxy'};
-    $self->{'proxyport'} = $arg{'proxyport'} if exists $arg{'proxyport'};
-    $self->{'ircname'} = $arg{'ircname'} if exists $arg{'ircname'};
-    $self->{'username'} = $arg{'username'} if exists $arg{'username'};
-    $self->{'NoDNS'} = $arg{'nodns'} if exists $arg{'nodns'};
-    $self->{'nat_addr'} = $arg{'nataddr'} if exists $arg{'nataddr'};
-    $self->{'user_bitmode'} = $arg{'bitmode'} if exists $arg{'bitmode'};
-    $self->{'compress'} = $arg{'compress'} if exists $arg{'compress'};
-    $self->{'socks_proxy'} = $arg{'socks_proxy'} if exists $arg{'socks_proxy'};
-    $self->{'socks_port'} = $arg{'socks_port'} if exists $arg{'socks_port'};
-    $self->{'socks_id'} = $arg{'socks_id'} if exists $arg{'socks_id'};
+    $self->set(\@password, $arg{'password'}) if exists $arg{'password'};
+    $self->set(\@localaddr, $arg{'localaddr'}) if exists $arg{'localaddr'};
+    $self->set(\@localport, $arg{'localport'}) if exists $arg{'localport'};
+    $self->set(\@nick, $arg{'nick'}) if exists $arg{'nick'};
+    $self->set(\@port, $arg{'port'}) if exists $arg{'port'};
+    $self->set(\@server, $arg{'server'}) if exists $arg{'server'};
+    $self->set(\@proxy, $arg{'proxy'}) if exists $arg{'proxy'};
+    $self->set(\@proxyport, $arg{'proxyport'}) if exists $arg{'proxyport'};
+    $self->set(\@ircname, $arg{'ircname'}) if exists $arg{'ircname'};
+    $self->set(\@username, $arg{'username'}) if exists $arg{'username'};
+    $self->set(\@NoDNS, $arg{'nodns'}) if exists $arg{'nodns'};
+    $self->set(\@nat_addr, $arg{'nataddr'}) if exists $arg{'nataddr'};
+    $self->set(\@user_bitmode, $arg{'bitmode'}) if exists $arg{'bitmode'};
+    $self->set(\@compress, $arg{'compress'}) if exists $arg{'compress'};
+    $self->set(\@socks_proxy, $arg{'socks_proxy'}) if exists $arg{'socks_proxy'};
+    $self->set(\@socks_port, $arg{'socks_port'}) if exists $arg{'socks_port'};
+    $self->set(\@socks_id, $arg{'socks_id'}) if exists $arg{'socks_id'};
 
     if (exists $arg{'debug'}) {
-      $self->{'debug'} = $arg{'debug'};
-      $self->{ircd_filter}->{DEBUG} = $arg{'debug'};
+      $self->set(\@debug, $arg{'debug'});
+      $self->ircd_filter()->{DEBUG} = $arg{'debug'};
     }
-    $self->{plugin_debug} = $arg{'plugin_debug'} if exists $arg{'plugin_debug'};
+    $self->set(\@plugin_debug, $arg{'plugin_debug'}) if exists $arg{'plugin_debug'};
     my $dccport = delete $arg{'dccports'};
-    $self->{'UseSSL'} = $arg{'usessl'} if exists $arg{'usessl'};
+    $self->set(\@UseSSL, $arg{'usessl'}) if exists $arg{'usessl'};
 
     if ( defined ( $dccport ) and ref ( $dccport ) eq 'ARRAY' ) {
-	  $self->{dcc_bind_port} = $dccport;
+	  $self->set(\@dcc_bind_port, $dccport);
     }
 
     if ( $arg{'resolver'} and $arg{'resolver'}->isa("POE::Component::Client::DNS") ) {
-	$self->{resolver} = $arg{'resolver'};
+	$self->set(\@resolver, $arg{'resolver'});
     }
 
     # This is a hack to make sure that the component doesn't die if no IRCServer is
@@ -226,29 +293,29 @@
     $spawned = $arg{'CALLED_FROM_SPAWN'};
   }
 
-  if ( $spawned and !$self->{NoDNS} and $GOT_CLIENT_DNS and !$self->{resolver} ) {
-	$self->{resolver} = POE::Component::Client::DNS->spawn( Alias => "resolver" . $self->session_id() );
-	$self->{mydns} = 1;
+  if ( $spawned and !$self->NoDNS() and $GOT_CLIENT_DNS and !$self->resolver ) {
+	$self->set(\@resolver, POE::Component::Client::DNS->spawn( Alias => "resolver" . $self->session_id() ));
+	$self->set(\@mydns, 1);
   }
 
   # Make sure that we have reasonable defaults for all the attributes.
   # The "IRC*" variables are ircII environment variables.
-  $self->{'nick'} = $ENV{IRCNICK} || eval { scalar getpwuid($>) } ||
-    $ENV{USER} || $ENV{LOGNAME} || "WankerBot"
-      unless ($self->{'nick'});
-  $self->{'username'} = eval { scalar getpwuid($>) } || $ENV{USER} ||
-    $ENV{LOGNAME} || "foolio"
-      unless ($self->{'username'});
-  $self->{'ircname'} = $ENV{IRCNAME} || eval { (getpwuid $>)[6] } ||
-    "Just Another Perl Hacker"
-      unless ($self->{'ircname'});
-  unless ($self->{'server'}) {
+  $self->set(\@nick, $ENV{IRCNICK} || eval { scalar getpwuid($>) } ||
+    $ENV{USER} || $ENV{LOGNAME} || "WankerBot")
+      unless ($self->nick);
+  $self->set(\@username, eval { scalar getpwuid($>) } || $ENV{USER} ||
+    $ENV{LOGNAME} || "foolio")
+      unless ($self->username);
+  $self->set(\@ircname, $ENV{IRCNAME} || eval { (getpwuid $>)[6] } ||
+    "Just Another Perl Hacker")
+      unless ($self->ircname);
+  unless ($self->server) {
     die "No IRC server specified" unless $ENV{IRCSERVER} or $spawned;
-    $self->{'server'} = $ENV{IRCSERVER};
+    $self->set(\@server, $ENV{IRCSERVER});
   }
-  $self->{'port'} = 6667 unless $self->{'port'};
-  if ($self->{localaddr} and $self->{localport}) {
-    $self->{localaddr} .= ":" . $self->{localport};
+  $self->set(\@port, 6667) unless $self->port;
+  if ($self->localaddr and $self->localport) {
+    $self->set(\@localaddr, $self->localaddr . ":" . $self->localport);
   }
 }
 
@@ -257,9 +324,9 @@
   my ($self, $operation, $errnum, $errstr, $id) =
     @_[OBJECT, ARG0 .. ARG3];
 
-  unless (exists $self->{dcc}->{$id}) {
-    if (exists $self->{wheelmap}->{$id}) {
-      $id = $self->{wheelmap}->{$id};
+  unless (exists $self->_dcc()->{$id}) {
+    if (exists $self->wheelmap()->{$id}) {
+      $id = $self->wheelmap()->{$id};
     } else {
       warn "_dcc_failed: Unknown wheel ID: $id";
       return;
@@ -267,36 +334,36 @@
   }
 
   # Reclaim our port if necessary.
-  if ( $self->{dcc}->{$id}->{listener} and $self->{dcc_bind_port} and $self->{dcc}->{$id}->{listenport} ) {
-	push ( @{ $self->{dcc_bind_port} }, $self->{dcc}->{$id}->{listenport} );
+  if ( $self->_dcc()->{$id}->{listener} and $self->dcc_bind_port and $self->_dcc()->{$id}->{listenport} ) {
+	push ( @{ $self->dcc_bind_port }, $self->_dcc()->{$id}->{listenport} );
   }
 
   # Did the peer of a DCC GET connection close the socket after the file
   # transfer finished? If so, it's not really an error.
   if ($errnum == 0 and
-  $self->{dcc}->{$id}->{type} eq "GET" and
-  $self->{dcc}->{$id}->{done} >= $self->{dcc}->{$id}->{size}) {
+  $self->_dcc()->{$id}->{type} eq "GET" and
+  $self->_dcc()->{$id}->{done} >= $self->_dcc()->{$id}->{size}) {
     $self->_send_event( 'irc_dcc_done', $id,
-    @{$self->{dcc}->{$id}}{ qw(nick type port file size done listenport clientaddr) } );
-    close $self->{dcc}->{$id}->{fh};
-    delete $self->{wheelmap}->{$self->{dcc}->{$id}->{wheel}->ID} if $self->{dcc}->{$id}->{wheel};
-    delete $self->{dcc}->{$id}->{wheel};
-    delete $self->{dcc}->{$id};
+    @{$self->_dcc()->{$id}}{ qw(nick type port file size done listenport clientaddr) } );
+    close $self->_dcc()->{$id}->{fh};
+    delete $self->wheelmap()->{$self->_dcc()->{$id}->{wheel}->ID} if $self->_dcc()->{$id}->{wheel};
+    delete $self->_dcc()->{$id}->{wheel};
+    delete $self->_dcc()->{$id};
   }
 
   elsif ($errnum == 0 and
-  $self->{dcc}->{$id}->{type} eq "CHAT") {
+  $self->_dcc()->{$id}->{type} eq "CHAT") {
     $self->_send_event( 'irc_dcc_done', $id,
-    @{$self->{dcc}->{$id}}{ qw(nick type port done listenport clientaddr) } );
-    #close $self->{dcc}->{$id}->{fh};
-    delete $self->{wheelmap}->{$self->{dcc}->{$id}->{wheel}->ID} if $self->{dcc}->{$id}->{wheel};
-    delete $self->{dcc}->{$id}->{wheel};
-    delete $self->{dcc}->{$id};
+    @{$self->_dcc()->{$id}}{ qw(nick type port done listenport clientaddr) } );
+    #close $self->_dcc()->{$id}->{fh};
+    delete $self->wheelmap()->{$self->_dcc()->{$id}->{wheel}->ID} if $self->_dcc()->{$id}->{wheel};
+    delete $self->_dcc()->{$id}->{wheel};
+    delete $self->_dcc()->{$id};
   }
 
   else {
     # In this case, something went wrong.
-    if ($errnum == 0 and $self->{dcc}->{$id}->{type} eq "GET") {
+    if ($errnum == 0 and $self->_dcc()->{$id}->{type} eq "GET") {
       $errstr = "Aborted by sender";
     }
     else {
@@ -308,14 +375,14 @@
       }
     }
     $self->_send_event( 'irc_dcc_error', $id, $errstr,
-		 @{$self->{dcc}->{$id}}{qw(nick type port file size done listenport clientaddr)} );
+		 @{$self->_dcc()->{$id}}{qw(nick type port file size done listenport clientaddr)} );
     # gotta close the file
-    close $self->{dcc}->{$id}->{fh} if exists $self->{dcc}->{$id}->{fh};
-    if (exists $self->{dcc}->{$id}->{wheel}) {
-      delete $self->{wheelmap}->{$self->{dcc}->{$id}->{wheel}->ID};
-      delete $self->{dcc}->{$id}->{wheel};
+    close $self->_dcc()->{$id}->{fh} if exists $self->_dcc()->{$id}->{fh};
+    if (exists $self->_dcc()->{$id}->{wheel}) {
+      delete $self->wheelmap()->{$self->_dcc()->{$id}->{wheel}->ID};
+      delete $self->_dcc()->{$id}->{wheel};
     }
-    delete $self->{dcc}->{$id};
+    delete $self->_dcc()->{$id};
   }
   undef;
 }
@@ -329,9 +396,9 @@
         $switch = 0;
     }
 
-    $self->{debug} = $switch;
-    $self->{ircd_filter}->debug( $switch );
-    $self->{ctcp_filter}->debug( $switch );
+    $self->set(\@debug, $switch);
+    $self->ircd_filter()->debug( $switch );
+    $self->ctcp_filter()->debug( $switch );
 }
 
 
@@ -339,52 +406,52 @@
 sub _dcc_read {
   my ($self, $data, $id) = @_[OBJECT, ARG0, ARG1];
 
-  $id = $self->{wheelmap}->{$id};
+  $id = $self->wheelmap()->{$id};
 
-  if ($self->{dcc}->{$id}->{type} eq "GET") {
+  if ($self->_dcc()->{$id}->{type} eq "GET") {
 
     # Acknowledge the received data.
-    print {$self->{dcc}->{$id}->{fh}} $data;
-    $self->{dcc}->{$id}->{done} += length $data;
-    $self->{dcc}->{$id}->{wheel}->put( pack "N", $self->{dcc}->{$id}->{done} );
+    print {$self->_dcc()->{$id}->{fh}} $data;
+    $self->_dcc()->{$id}->{done} += length $data;
+    $self->_dcc()->{$id}->{wheel}->put( pack "N", $self->_dcc()->{$id}->{done} );
 
     # Send an event to let people know about the newly arrived data.
     $self->_send_event( 'irc_dcc_get', $id,
-		 @{$self->{dcc}->{$id}}{ qw(nick port file size done listenport clientaddr) } );
+		 @{$self->_dcc()->{$id}}{ qw(nick port file size done listenport clientaddr) } );
 
 
-  } elsif ($self->{dcc}->{$id}->{type} eq "SEND") {
+  } elsif ($self->_dcc()->{$id}->{type} eq "SEND") {
 
     # Record the client's download progress.
-    $self->{dcc}->{$id}->{done} = unpack "N", substr( $data, -4 );
+    $self->_dcc()->{$id}->{done} = unpack "N", substr( $data, -4 );
     $self->_send_event( 'irc_dcc_send', $id,
-		 @{$self->{dcc}->{$id}}{ qw(nick port file size done listenport clientaddr) } );
+		 @{$self->_dcc()->{$id}}{ qw(nick port file size done listenport clientaddr) } );
 
     # Are we done yet?
-    if ($self->{dcc}->{$id}->{done} >= $self->{dcc}->{$id}->{size}) {
+    if ($self->_dcc()->{$id}->{done} >= $self->_dcc()->{$id}->{size}) {
 
       # Reclaim our port if necessary.
-      if ( $self->{dcc}->{$id}->{listener} and $self->{dcc_bind_port} and $self->{dcc}->{$id}->{listenport} ) {
-        push ( @{ $self->{dcc_bind_port} }, $self->{dcc}->{$id}->{listenport} );
+      if ( $self->_dcc()->{$id}->{listener} and $self->dcc_bind_port() and $self->_dcc()->{$id}->{listenport} ) {
+        push ( @{ $self->dcc_bind_port() }, $self->_dcc()->{$id}->{listenport} );
       }
 
       $self->_send_event( 'irc_dcc_done', $id,
-		   @{$self->{dcc}->{$id}}{ qw(nick type port file size done listenport clientaddr) }
+		   @{$self->_dcc()->{$id}}{ qw(nick type port file size done listenport clientaddr) }
 		 );
-      delete $self->{wheelmap}->{$self->{dcc}->{$id}->{wheel}->ID};
-      delete $self->{dcc}->{$id}->{wheel};
-      delete $self->{dcc}->{$id};
+      delete $self->wheelmap()->{$self->_dcc()->{$id}->{wheel}->ID};
+      delete $self->_dcc()->{$id}->{wheel};
+      delete $self->_dcc()->{$id};
       return;
     }
 
     # Send the next 'blocksize'-sized packet.
-    read $self->{dcc}->{$id}->{fh}, $data, $self->{dcc}->{$id}->{blocksize};
-    $self->{dcc}->{$id}->{wheel}->put( $data );
+    read $self->_dcc()->{$id}->{fh}, $data, $self->_dcc()->{$id}->{blocksize};
+    $self->_dcc()->{$id}->{wheel}->put( $data );
 
   }
   else {
-    $self->_send_event( 'irc_dcc_' . lc $self->{dcc}->{$id}->{type},
-		 $id, @{$self->{dcc}->{$id}}{'nick', 'port'}, $data );
+    $self->_send_event( 'irc_dcc_' . lc $self->_dcc()->{$id}->{type},
+		 $id, @{$self->_dcc()->{$id}}{'nick', 'port'}, $data );
   }
   undef;
 }
@@ -395,7 +462,7 @@
 sub _dcc_timeout {
   my ($kernel, $self, $id) = @_[KERNEL, OBJECT, ARG0];
 
-  if (exists $self->{dcc}->{$id} and !$self->{dcc}->{$id}->{open}) {
+  if (exists $self->_dcc()->{$id} and !$self->_dcc()->{$id}->{open}) {
     $kernel->yield( '_dcc_failed', 'connection', 0,
 		    'DCC connection timed out', $id );
   }
@@ -411,15 +478,15 @@
   my $buf = '';
 
   # Monitor the new socket for incoming data and delete the listening socket.
-  delete $self->{dcc}->{$id}->{factory};
-  $self->{dcc}->{$id}->{addr} = $addr;
-  $self->{dcc}->{$id}->{clientaddr} = inet_ntoa($addr);
-  $self->{dcc}->{$id}->{port} = $port;
-  $self->{dcc}->{$id}->{open} = 1;
+  delete $self->_dcc()->{$id}->{factory};
+  $self->_dcc()->{$id}->{addr} = $addr;
+  $self->_dcc()->{$id}->{clientaddr} = inet_ntoa($addr);
+  $self->_dcc()->{$id}->{port} = $port;
+  $self->_dcc()->{$id}->{open} = 1;
   #bboett: -second step - the connection per DCC is opened, following the protocol we have to send a PRIVMSG User1 :DCC RESUME filename port position
   #set the correct filter....
   my $actualFilter = "";
-  if($self->{dcc}->{$id}->{type} eq "CHAT" )
+  if($self->_dcc()->{$id}->{type} eq "CHAT" )
   {
     $actualFilter = POE::Filter::Line->new( Literal => "\012" );
   }# if("CHAT")
@@ -429,34 +496,34 @@
     $actualFilter = POE::Filter::Stream->new() ;
   }# else
   #->bboett
-  $self->{dcc}->{$id}->{wheel} = POE::Wheel::ReadWrite->new(
+  $self->_dcc()->{$id}->{wheel} = POE::Wheel::ReadWrite->new(
       Handle => $sock,
-      Driver => ($self->{dcc}->{$id}->{type} eq "GET" ?
+      Driver => ($self->_dcc()->{$id}->{type} eq "GET" ?
 		   POE::Driver::SysRW->new( BlockSize => INCOMING_BLOCKSIZE ) :
 		   POE::Driver::SysRW->new() ),
-#Filter => ($self->{dcc}->{$id}->{type} eq "CHAT" ?
+#Filter => ($self->_dcc()->{$id}->{type} eq "CHAT" ?
 #	       POE::Filter::Line->new( Literal => "\012" ) :
 #	       POE::Filter::Stream->new() ),
       Filter => $actualFilter, #bboett
       InputEvent => '_dcc_read',
       ErrorEvent => '_dcc_failed',
   );
-  $self->{wheelmap}->{$self->{dcc}->{$id}->{wheel}->ID} = $id;
+  $self->wheelmap()->{$self->_dcc()->{$id}->{wheel}->ID} = $id;
 
-  if ($self->{dcc}->{$id}->{'type'} eq 'GET') {
+  if ($self->_dcc()->{$id}->{'type'} eq 'GET') {
     my $handle = gensym();
     #bboett: added a check if the size is !=0 we suppose a resume
-    if(-s $self->{dcc}->{$id}->{file})
+    if(-s $self->_dcc()->{$id}->{file})
     {
-      unless (open $handle, ">>" . $self->{dcc}->{$id}->{file})
+      unless (open $handle, ">>" . $self->_dcc()->{$id}->{file})
       {
 	$kernel->yield( '_dcc_failed', 'open file', $! + 0, "$!", $id );
 	return;
-      }# unless (open $handle, ">>" . $self->{dcc}->{$id}->{file})
-    }# if(-s $self->{dcc}->{$id}->{file})
+      }# unless (open $handle, ">>" . $self->_dcc()->{$id}->{file})
+    }# if(-s $self->_dcc()->{$id}->{file})
     else
     {
-      unless (open $handle, ">" . $self->{dcc}->{$id}->{file}) {
+      unless (open $handle, ">" . $self->_dcc()->{$id}->{file}) {
 	$kernel->yield( '_dcc_failed', 'open file', $! + 0, "$!", $id );
 	return;
       }
@@ -464,31 +531,31 @@
     binmode $handle;
 
     # Store the filehandle with the rest of this connection's state.
-    $self->{dcc}->{$id}->{'fh'} = $handle;
+    $self->_dcc()->{$id}->{'fh'} = $handle;
 
   }
-  elsif ($self->{dcc}->{$id}->{type} eq 'SEND') {
+  elsif ($self->_dcc()->{$id}->{type} eq 'SEND') {
     # Open up the file we're going to send.
     my $handle = gensym();
-    unless (open $handle, "<" . $self->{dcc}->{$id}->{'file'}) {
+    unless (open $handle, "<" . $self->_dcc()->{$id}->{'file'}) {
       $kernel->yield( '_dcc_failed', 'open file', $! + 0, "$!", $id );
       return;
     }
     binmode $handle;
 
     # Send the first packet to get the ball rolling.
-    read $handle, $buf, $self->{dcc}->{$id}->{'blocksize'};
-    $self->{dcc}->{$id}->{wheel}->put( $buf );
+    read $handle, $buf, $self->_dcc()->{$id}->{'blocksize'};
+    $self->_dcc()->{$id}->{wheel}->put( $buf );
 
     # Store the filehandle with the rest of this connection's state.
-    $self->{dcc}->{$id}->{'fh'} = $handle;
+    $self->_dcc()->{$id}->{'fh'} = $handle;
   }
 
   # Tell any listening sessions that the connection is up.
   $self->_send_event( 'irc_dcc_start',
-	       $id, @{$self->{dcc}->{$id}}{'nick', 'type', 'port'},
-	       ($self->{dcc}->{$id}->{'type'} =~ /^(SEND|GET)$/ ?
-		(@{$self->{dcc}->{$id}}{'file', 'size'}) : ()), @{$self->{dcc}->{$id}}{'listenport', 'clientaddr'} );
+	       $id, @{$self->_dcc()->{$id}}{'nick', 'type', 'port'},
+	       ($self->_dcc()->{$id}->{'type'} =~ /^(SEND|GET)$/ ?
+		(@{$self->_dcc()->{$id}}{'file', 'size'}) : ()), @{$self->_dcc()->{$id}}{'listenport', 'clientaddr'} );
   undef;
 }
 
@@ -499,12 +566,12 @@
 
   return unless $ev->{name};
 
-  $self->_send_event( 'irc_raw' => $ev->{raw_line} ) if $self->{raw_events};
+  $self->_send_event( 'irc_raw' => $ev->{raw_line} ) if $self->raw_events();
 
   # If its 001 event grab the server name and stuff it into {INFO}
   if ( $ev->{name} eq '001' ) {
-	$self->{INFO}->{ServerName} = $ev->{args}->[0];
-	$self->{RealNick} = ( split / /, $ev->{raw_line} )[2];
+	$self->INFO()->{ServerName} = $ev->{args}->[0];
+	$self->RealNick(( split / /, $ev->{raw_line} )[2]);
   }
   $ev->{name} = 'irc_' . $ev->{name};
   $self->_send_event( $ev->{name}, @{$ev->{args}} );
@@ -513,7 +580,7 @@
 
 sub send_event {
   my $self = shift;
-  $poe_kernel->call( $self->{SESSION_ID}, '__send_event', @_ );
+  $poe_kernel->call( $self->SESSION_ID(), '__send_event', @_ );
   return 1;
 }
 
@@ -541,7 +608,7 @@
   # I've moved these above the plugin system call to ensure that pesky plugins 
   # don't eat the events before *our* session can process them. *sigh*
 
-  $sessions{$_} = $_ for (values %{$self->{events}->{'irc_all'}}, values %{$self->{events}->{$event}});
+  $sessions{$_} = $_ for (values %{$self->events()->{'irc_all'}}, values %{$self->events()->{$event}});
 
   # Make sure our session gets notified of any requested events before any other bugger
   $kernel->call( $session => $event => @args ) if delete $sessions{$session};
@@ -557,8 +624,8 @@
   # 'irc_disconnected' events to every registered session regardless of whether
   # that session had registered from them or not.
   if ( $event =~ /connected$/ or $event eq 'irc_shutdown' ) {
-    $kernel->post( $self->{sessions}->{$_}->{'ref'},
-		   $event, @args ) for keys %{ $self->{sessions} };
+    $kernel->post( $self->sessions()->{$_}->{'ref'},
+		   $event, @args ) for keys %{ $self->sessions() };
     return 1;
   }
 
@@ -568,8 +635,8 @@
 
 sub _sock_flush {
   my ($kernel, $self) = @_[KERNEL, OBJECT];
-  return unless $self->{_shutdown};
-  delete $self->{'socket'};
+  return unless $self->_shutdown();
+  $self->set(\@socket, undef);
   undef;
 }
 
@@ -578,13 +645,13 @@
   my ($kernel, $self) = @_[KERNEL, OBJECT];
 
   # Destroy the RW wheel for the socket.
-  delete $self->{'socket'};
-  $self->{connected} = 0;
+  $self->set(\@socket, undef);
+  $self->set(\@connected, 0);
 
   # Stop any delayed sends.
-  $self->{send_queue} = [ ];
+  $self->set(\@send_queue, [ ]);
   #$_[HEAP]->{send_queue} = $self->{send_queue};
-  $self->{send_time}  = 0;
+  $self->set(\@send_time, 0);
   $kernel->delay( sl_delayed => undef );
 
   # Reset the filters if necessary
@@ -592,7 +659,7 @@
   $self->_compress_downlink( 0 );
 
   # post a 'irc_disconnected' to each session that cares
-  $self->_send_event( 'irc_disconnected', $self->{server} );
+  $self->_send_event( 'irc_disconnected', $self->server() );
   undef;
 }
 
@@ -605,7 +672,7 @@
 sub _sock_failed {
   my ($self, $op, $errno, $errstr) = @_[OBJECT, ARG0..ARG2];
 
-  delete $self->{'socketfactory'};
+  $self->set(\@socketfactory, undef);
   $self->_send_event( 'irc_socketerr', "$op error $errno: $errstr" );
   undef;
 }
@@ -616,86 +683,86 @@
   my ($kernel, $self, $session, $socket) = @_[KERNEL, OBJECT, SESSION, ARG0];
 
   # We no longer need the SocketFactory wheel. Scrap it.
-  delete $self->{'socketfactory'};
+  $self->set(\@socketfactory, undef);
 
   # Remember what IP address we're connected through, for multihomed boxes.
-  $self->{'localaddr'} = (unpack_sockaddr_in( getsockname $socket ))[1];
+  $self->set(\@localaddr, (unpack_sockaddr_in( getsockname $socket ))[1]);
 
-  if ( $self->{socks_proxy} ) {
-    $self->{'socket'} = new POE::Wheel::ReadWrite
+  if ( $self->socks_proxy() ) {
+    $self->set(\@socket, new POE::Wheel::ReadWrite
     ( Handle       => $socket,
       Driver       => POE::Driver::SysRW->new(),
       Filter	   => POE::Filter::Stream->new(),
       InputEvent   => '_socks_proxy_response',
       ErrorEvent   => '_sock_down',
       FlushedEvent => '_sock_flush',
-    );
-    unless ( $self->{'socket'} ) {
+    ));
+    unless ( $self->socket() ) {
 	$self->_send_event( 'irc_socketerr', "Couldn't create ReadWrite wheel for SOCKS socket" );
 	return;
     }
     my $packet;
-    if ( $self->{server} =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/ ) {
+    if ( $self->server() =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/ ) {
       # SOCKS 4
-      $packet = pack ('CCn', 4, 1, $self->{port}) .
-	inet_aton($self->{server}) . ( $self->{socks_id} || '' ) . (pack 'x');
+      $packet = pack ('CCn', 4, 1, $self->port) .
+	inet_aton($self->server) . ( $self->socks_id || '' ) . (pack 'x');
     }
     else {
       # SOCKS 4a
-      $packet = pack ('CCn', 4, 1, $self->{port}) .
-	inet_aton('0.0.0.1') . ( $self->{socks_id} || '' ) . (pack 'x') .
-	$self->{server} . (pack 'x');
+      $packet = pack ('CCn', 4, 1, $self->port) .
+	inet_aton('0.0.0.1') . ( $self->socks_id || '' ) . (pack 'x') .
+	$self->server . (pack 'x');
     }
-    $self->{'socket'}->put( $packet );
+    $self->socket()->put( $packet );
     return;
   }
 
   #ssl!
-  if ($GOT_SSL and $self->{'UseSSL'}) {
+  if ($GOT_SSL and $self->UseSSL) {
     eval {
       $socket = Client_SSLify( $socket );
     };
     if ($@) {
       #something didn't work
       warn "Couldn't use an SSL socket: $@ \n";
-      $self->{'UseSSL'} = 0;
+      $self->set(\@UseSSL, 0);
     }
   }
 
-  if ( $self->{compress} ) {
+  if ( $self->compress ) {
 	$self->_compress_uplink(1);
 	$self->_compress_downlink(1);
   }
   # Create a new ReadWrite wheel for the connected socket.
-  $self->{'socket'} = new POE::Wheel::ReadWrite
+  $self->set(\@socket, new POE::Wheel::ReadWrite
     ( Handle       => $socket,
       Driver       => POE::Driver::SysRW->new(),
-      InputFilter  => $self->{srv_filter},
-      OutputFilter => $self->{out_filter},
+      InputFilter  => $self->srv_filter,
+      OutputFilter => $self->out_filter,
       InputEvent   => '_parseline',
       ErrorEvent   => '_sock_down',
       FlushedEvent => '_sock_flush',
-    );
+    ));
 
-  if ($self->{'socket'}) {
-    $self->{connected} = 1;
+  if ($self->socket) {
+    $self->set(\@connected, 1);
   } else {
     $self->_send_event( 'irc_socketerr', "Couldn't create ReadWrite wheel for IRC socket" );
   }
 
   # Post a 'irc_connected' event to each session that cares
-  $self->_send_event( 'irc_connected', $self->{server} );
+  $self->_send_event( 'irc_connected', $self->server() );
 
   # CONNECT if we're using a proxy
-  if ($self->{proxy}) {
+  if ($self->proxy) {
     
     #The original proxy code, AFAIK, did not actually work with an HTTP proxy.
-    $kernel->call($session, 'sl_login', 'CONNECT ' . $self->{'server'} . ":" . $self->{'port'} . " HTTP/1.0\n\n");
+    $kernel->call($session, 'sl_login', 'CONNECT ' . $self->server . ":" . $self->port . " HTTP/1.0\n\n");
 
     #KLUDGE: Also, the original proxy code assumes the connection is instantaneous
     #Since this is not always the case, mess with the queueing so that the sent text 
     #is delayed...
-    $self->{send_time} = time() + 10;
+    $self->set(\@send_time, time() + 10);
   }
   $kernel->yield( '_send_login' );
   undef;
@@ -716,12 +783,12 @@
   }
   if ( $resp[1] eq '90' ) {
      $kernel->call( $session, '_socks_proxy_connect' );
-     $self->{connected} = 1;
-     $self->_send_event( 'irc_connected', $self->{server} );
+     $self->set(\@connected, 1);
+     $self->_send_event( 'irc_connected', $self->server );
      $kernel->yield( '_send_login' );
   }
   else {
-     $self->_send_event( 'irc_socks_rejected', $resp[1], $self->{socks_proxy}, $self->{socks_port}, $self->{socks_id} );
+     $self->_send_event( 'irc_socks_rejected', $resp[1], $self->socks_proxy, $self->socks_port, $self->socks_id );
      $self->disconnect();
   }
   undef;
@@ -729,9 +796,9 @@
 
 sub _socks_proxy_connect {
   my ($kernel,$self) = @_[KERNEL,OBJECT];
-  $self->{socket}->event( InputEvent => '_parseline' );
-  $self->{socket}->set_input_filter( $self->{srv_filter} );
-  $self->{socket}->set_output_filter( $self->{out_filter} );
+  $self->socket()->event( InputEvent => '_parseline' );
+  $self->socket()->set_input_filter( $self->srv_filter );
+  $self->socket()->set_output_filter( $self->out_filter );
   undef;
 }
 
@@ -739,15 +806,15 @@
   my ($kernel,$self,$session) = @_[KERNEL,OBJECT,SESSION];
 
   # Now that we're connected, attempt to log into the server.
-  if ($self->{password}) {
-    $kernel->call( $session, 'sl_login', "PASS " . $self->{password} );
+  if ($self->password) {
+    $kernel->call( $session, 'sl_login', "PASS " . $self->password );
   }
-  $kernel->call( $session, 'sl_login', "NICK " . $self->{nick} );
+  $kernel->call( $session, 'sl_login', "NICK " . $self->nick );
   $kernel->call( $session, 'sl_login', "USER " .
-		 join( ' ', $self->{username},
-		       ($self->{'user_bitmode'} ? $self->{'user_bitmode'} : 0),
+		 join( ' ', $self->username,
+		       ($self->user_bitmode ? $self->user_bitmode : 0),
 		       '*',
-		       ':' . $self->{ircname} ));
+		       ':' . $self->ircname ));
 
   # If we have queued data waiting, its flush loop has stopped
   # while we were disconnected.  Start that up again.
@@ -768,49 +835,49 @@
 
   # Send queue is used to hold pending lines so we don't flood off.
   # The count is used to track the number of lines sent at any time.
-  $self->{send_queue} = [ ];
-  $self->{send_time}  = 0;
+  $self->set(\@send_queue, [ ]);
+  $self->set(\@send_time, 0);
 
   $session->option( @options ) if @options;
 
   if ( $alias ) {
      $kernel->alias_set($alias);
-     $self->{alias} = $alias;
+     $self->set(\@alias, $alias);
   } else {
      $kernel->alias_set("$self");
-     $self->{alias} = "$self";
+     $self->set(\@alias, "$self");
   }
 
-  $self->{ircd_filter} = POE::Filter::IRCD->new( DEBUG => $self->{debug} );
-  $self->{ircd_compat} = POE::Filter::IRC::Compat->new( DEBUG => $self->{debug} );
-  $self->{ctcp_filter} = POE::Filter::CTCP->new();
+  $self->set(\@ircd_filter, POE::Filter::IRCD->new( DEBUG => $self->_debug ));
+  $self->set(\@ircd_compat, POE::Filter::IRC::Compat->new( DEBUG => $self->_debug ));
+  $self->set(\@ctcp_filter, POE::Filter::CTCP->new());
   my $filters = [
 		   POE::Filter::Line->new( InputRegexp => '\015?\012',
 					    OutputLiteral => "\015\012" ),
-		   $self->{ircd_filter},
-		   $self->{ircd_compat},
+		   $self->ircd_filter,
+		   $self->ircd_compat,
 		];
 		   
-  $self->{srv_filter} = POE::Filter::Stackable->new( Filters => $filters );
-  $self->{out_filter} = POE::Filter::Stackable->new( Filters => [ POE::Filter::Line->new( OutputLiteral => "\015\012" ) ] );
+  $self->set(\@srv_filter, POE::Filter::Stackable->new( Filters => $filters ));
+  $self->set(\@out_filter, POE::Filter::Stackable->new( Filters => [ POE::Filter::Line->new( OutputLiteral => "\015\012" ) ] ));
 
   eval{ 
 	require POE::Filter::Zlib::Stream;
   };
-  $self->{can_do_zlib} = 1 unless $@;
-  $self->{SESSION_ID} = $session->ID();
+  $self->set(\@can_do_zlib, 1) unless $@;
+  $self->set(\@SESSION_ID, $session->ID());
 
   # Plugin 'irc_whois' and 'irc_whowas' support
-  $self->plugin_add ( 'Whois' . $self->{SESSION_ID}, POE::Component::IRC::Plugin::Whois->new() );
+  $self->plugin_add ( 'Whois' . $self->SESSION_ID(), POE::Component::IRC::Plugin::Whois->new() );
 
-  $self->{isupport} = POE::Component::IRC::Plugin::ISupport->new();
-  $self->plugin_add( 'ISupport' . $self->{SESSION_ID}, $self->{isupport} );
+  $self->set(\@isupport, POE::Component::IRC::Plugin::ISupport->new());
+  $self->plugin_add( 'ISupport' . $self->SESSION_ID, $self->_isupport );
 
   if ( $kernel != $sender ) {
     my $sender_id = $sender->ID;
-    $self->{events}->{'irc_all'}->{$sender_id} = $sender_id;
-    $self->{sessions}->{$sender_id}->{'ref'} = $sender_id;
-    $self->{sessions}->{$sender_id}->{refcnt}++;
+    $self->events()->{'irc_all'}->{$sender_id} = $sender_id;
+    $self->sessions()->{$sender_id}->{'ref'} = $sender_id;
+    $self->sessions()->{$sender_id}->{refcnt}++;
     $kernel->refcount_increment($sender_id, PCI_REFCOUNT_TAG);
     $kernel->post( $sender, 'irc_registered', $self );
   }
@@ -823,7 +890,7 @@
 sub _stop {
   my ($kernel, $self, $quitmsg) = @_[KERNEL, OBJECT, ARG0];
 
-  if ($self->{connected}) {
+  if ($self->connected) {
     $kernel->call( $_[SESSION], 'quit', $quitmsg );
     $kernel->call( $_[SESSION], 'shutdown', $quitmsg );
   }
@@ -845,7 +912,7 @@
     $args = join ',', @args;
   }
 
-  my $pri = $self->{IRC_CMDS}->{$state}->[CMD_PRI];
+  my $pri = $self->IRC_CMDS()->{$state}->[CMD_PRI];
 
   $state = uc $state;
   $state .= " $args" if defined $args;
@@ -878,14 +945,14 @@
 
   $self->_configure( \%arg );
 
-  if ( $self->{resolver} and $self->{res_addresses} and scalar @{ $self->{res_addresses} } ) {
-	push @{ $self->{res_addresses} }, $self->{'server'};
-	$self->{'server'} = shift @{ $self->{res_addresses} };
+  if ( $self->resolver and $self->res_addresses and scalar @{ $self->res_addresses } ) {
+	push @{ $self->res_addresses }, $self->server;
+	$self->set(\@server, shift @{ $self->res_addresses });
   }
 
   # try and use non-blocking resolver if needed
-  if ( $self->{resolver} && $self->{'server'} !~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/ && !$self->{'NoDNS'} ) {
-    my $response = $self->{resolver}->resolve( event => "_got_dns_response", host =>  $self->{'server'}, context => { } );
+  if ( $self->resolver && $self->server !~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/ && !$self->NoDNS ) {
+    my $response = $self->resolver()->resolve( event => "_got_dns_response", host =>  $self->server, context => { } );
     if ( $response ) {
 	$kernel->yield( _got_dns_response => $response );
     }
@@ -893,7 +960,7 @@
     $kernel->yield("_do_connect");
   }
 
-  $self->{RealNick} = $self->{nick};
+  $self->set(\@RealNick, $self->nick());
   undef;
 }
 
@@ -902,22 +969,22 @@
   my ($kernel,$self,$session) = @_[KERNEL,OBJECT,SESSION];
 
   # Disconnect if we're already logged into a server.
-  $kernel->call( $session, 'quit' ) if $self->{'socket'};
+  $kernel->call( $session, 'quit' ) if $self->socket();
 
-  $self->{socks_port} = 1080 if $self->{socks_proxy} and !$self->{socks_port};
+  $self->set(\@socks_port, 1080) if $self->socks_proxy and !$self->socks_port;
 
-  $self->{'socketfactory'} =
-  POE::Wheel::SocketFactory->new( 
+  $self->set(\@socketfactory,
+    POE::Wheel::SocketFactory->new( 
 	SocketDomain   => AF_INET,
 	SocketType     => SOCK_STREAM,
 	SocketProtocol => 'tcp',
-	RemoteAddress  => $self->{socks_proxy} || $self->{'proxy'} || $self->{'server'},
-	RemotePort     => $self->{socks_port} || $self->{'proxyport'} || $self->{'port'},
+	RemoteAddress  => $self->socks_proxy || $self->proxy || $self->server,
+	RemotePort     => $self->socks_port || $self->proxyport || $self->port,
 	SuccessEvent   => '_sock_up',
 	FailureEvent   => '_sock_failed',
-	($self->{localaddr} ?
-	       (BindAddress => $self->{localaddr}) : ()),
-  );
+	($self->localaddr ?
+	       (BindAddress => $self->localaddr) : ()),
+  ));
   undef;
 }
 
@@ -926,7 +993,7 @@
   my ($kernel,$self) = @_[KERNEL,OBJECT];
   my ($net_dns_packet) = $_[ARG0]->{response};
   my ($net_dns_errorstring) = $_[ARG0]->{error};
-  $self->{res_addresses} = [ ] unless $self->{res_addresses};
+  $self->set(\@res_addresses, [ ]) unless $self->res_addresses;
 
   unless(defined $net_dns_packet) {
     $self->_send_event( 'irc_socketerr', $net_dns_errorstring );
@@ -936,22 +1003,22 @@
   my @net_dns_answers = $net_dns_packet->answer;
 
   unless (@net_dns_answers) {
-    $self->_send_event( 'irc_socketerr', "Unable to resolve $self->{'server'}");
+    $self->_send_event( 'irc_socketerr', "Unable to resolve " . $self->server);
     return;
   }
 
   foreach my $net_dns_answer (@net_dns_answers) {
     next unless $net_dns_answer->type eq "A";
-    push @{ $self->{res_addresses} }, $net_dns_answer->rdatastr;
+    push @{ $self->res_addresses }, $net_dns_answer->rdatastr;
   }
 
-  if ( my $address = shift @{ $self->{res_addresses} } ) {
-    $self->{'server'} = $address;
+  if ( my $address = shift @{ $self->res_addresses } ) {
+    $self->set(\@server, $address);
     $kernel->yield("_do_connect");
     return;
   }
 
-  $self->_send_event( 'irc_socketerr', "Unable to resolve $self->{'server'}");
+  $self->_send_event( 'irc_socketerr', "Unable to resolve " . $self->server);
   undef;
 }
 
@@ -966,7 +1033,7 @@
   }
 
   # CTCP-quote the message text.
-  ($message) = @{$self->{ctcp_filter}->put([ $message ])};
+  ($message) = @{$self->ctcp_filter()->put([ $message ])};
 
   # Should we send this as a CTCP request or reply?
   $state = $state eq 'ctcpreply' ? 'notice' : 'privmsg';
@@ -1009,14 +1076,14 @@
     }
   }
 
-  if ($self->{localaddr} and $self->{localaddr} =~ tr/a-zA-Z.//) {
-    $self->{localaddr} = inet_aton( $self->{localaddr} );
+  if ($self->localaddr and $self->localaddr =~ tr/a-zA-Z.//) {
+    $self->set(\@localaddr, inet_aton( $self->localaddr ));
   }
 
   my $bindport = 0;
 
-  if ( $self->{dcc_bind_port} ) {
-	$bindport = shift @{ $self->{dcc_bind_port} };
+  if ( $self->dcc_bind_port ) {
+	$bindport = shift @{ $self->dcc_bind_port };
 	unless ($bindport) {
 		warn "dcc: Can't allocate listen port for DCC $type";
 		return;
@@ -1024,14 +1091,14 @@
   }
 
   $factory = POE::Wheel::SocketFactory->new(
-      BindAddress  => $self->{localaddr} || INADDR_ANY,
+      BindAddress  => $self->localaddr || INADDR_ANY,
       BindPort     => $bindport,
       SuccessEvent => '_dcc_up',
       FailureEvent => '_dcc_failed',
       Reuse        => 'yes',
   );
   ($port, $myaddr) = unpack_sockaddr_in( $factory->getsockname() );
-  $myaddr = inet_aton( $self->{nat_addr} ) if $self->{nat_addr};
+  $myaddr = inet_aton( $self->nat_addr ) if $self->nat_addr;
   unless ($myaddr) {
     warn "dcc: Can't determine our IP address! ($!)";
     return;
@@ -1046,7 +1113,7 @@
 		  . ($size ? " $size" : "") );
 
   # Store the state for this connection.
-  $self->{dcc}->{$factory->ID} = { open => undef,
+  $self->_dcc()->{$factory->ID} = { open => undef,
 				   nick => $nick,
 				   type => $type,
 				   file => $file,
@@ -1088,8 +1155,8 @@
       SuccessEvent  => '_dcc_up',
       FailureEvent  => '_dcc_failed',
   );
-  $self->{dcc}->{$factory->ID} = $cookie;
-  $self->{dcc}->{$factory->ID}->{factory} = $factory;
+  $self->_dcc()->{$factory->ID} = $cookie;
+  $self->_dcc()->{$factory->ID}->{factory} = $factory;
 }
 # bboett - first step - the user asks for a resume:
 # tries to resume a previous dcc transfer. See '_dcc_up' for
@@ -1127,7 +1194,7 @@
 
 	my $message = 'DCC RESUME '.$cookie->{file}." ".$cookie->{port}." ".$mysize.'';
 	my $state = 'PRIVMSG';
-	my $pri = $self->{IRC_CMDS}->{$state}->[CMD_PRI];
+	my $pri = $self->IRC_CMDS()->{$state}->[CMD_PRI];
 
 	$state .= " $nick :$message";
 	$kernel->yield( 'sl_prioritized', $pri, $state );
@@ -1142,15 +1209,15 @@
 sub dcc_chat {
   my ($kernel, $self, $id, @data) = @_[KERNEL, OBJECT, ARG0, ARG1 .. $#_];
 
-  unless (exists $self->{dcc}->{$id}) {
+  unless (exists $self->_dcc()->{$id}) {
     warn "dcc_chat: Unknown wheel ID: $id";
     return;
   }
-  unless (exists $self->{dcc}->{$id}->{wheel}) {
+  unless (exists $self->_dcc()->{$id}->{wheel}) {
     warn "dcc_chat: No DCC wheel for $id!";
     return;
   }
-  unless ($self->{dcc}->{$id}->{type} eq "CHAT") {
+  unless ($self->_dcc()->{$id}->{type} eq "CHAT") {
     warn "dcc_chat: $id isn't a DCC CHAT connection!";
     return;
   }
@@ -1160,7 +1227,7 @@
   	return 1;
   }
 
-  $self->{dcc}->{$id}->{wheel}->put( join "\n", @data );
+  $self->_dcc()->{$id}->{wheel}->put( join "\n", @data );
   undef;
 }
 
@@ -1169,7 +1236,7 @@
 sub dcc_close {
   my ($kernel, $self, $id) = @_[KERNEL, OBJECT, ARG0];
 
-  if ($self->{dcc}->{$id}->{wheel}->get_driver_out_octets()) {
+  if ($self->_dcc()->{$id}->{wheel}->get_driver_out_octets()) {
     $kernel->delay( _tryclose => .2 => @_[ARG0..$#_] );
     return;
   }
@@ -1180,18 +1247,18 @@
   }
 
   $self->_send_event( 'irc_dcc_done', $id,
-	       @{$self->{dcc}->{$id}}{ qw(nick type port file size done listenport clientaddr) } );
+	       @{$self->_dcc()->{$id}}{ qw(nick type port file size done listenport clientaddr) } );
 
   # Reclaim our port if necessary.
-  if ( $self->{dcc}->{$id}->{listener} and $self->{dcc_bind_port} and $self->{dcc}->{$id}->{listenport} ) {
-	push ( @{ $self->{dcc_bind_port} }, $self->{dcc}->{$id}->{listenport} );
+  if ( $self->_dcc()->{$id}->{listener} and $self->dcc_bind_port and $self->_dcc()->{$id}->{listenport} ) {
+	push ( @{ $self->dcc_bind_port }, $self->_dcc()->{$id}->{listenport} );
   }
 
-  if (exists $self->{dcc}->{$id}->{wheel}) {
-    delete $self->{wheelmap}->{$self->{dcc}->{$id}->{wheel}->ID};
-    delete $self->{dcc}->{$id}->{wheel};
+  if (exists $self->_dcc()->{$id}->{wheel}) {
+    delete $self->wheelmap()->{$self->_dcc()->{$id}->{wheel}->ID};
+    delete $self->_dcc()->{$id}->{wheel};
   }
-  delete $self->{dcc}->{$id};
+  delete $self->_dcc()->{$id};
   undef;
 }
 
@@ -1253,17 +1320,6 @@
   undef;
 }
 
-# Set up a new IRC component. Deprecated.
-sub new {
-  my ($package, $alias) = splice @_, 0, 2;
-
-  croak "Not enough arguments to POE::Component::IRC::new()" unless $alias;
-  warn join ' ', "Use of $package->new() is deprecated, please use spawn(). Called from ", caller(), "\n";
-  my $self = $package->spawn ( alias => $alias, options => { @_ } );
-
-  return $self;
-}
-
 # Set up a new IRC component. New interface.
 sub spawn {
   my $package = shift;
@@ -1274,15 +1330,19 @@
 
   delete $parms{'options'} unless ref ( $parms{'options'} ) eq 'HASH';
 
-  my $self = bless { }, $package;
+  my $self = $package->new(%parms);
   $self->_create();
+  
+  $self->set(\@events, { });
+  $self->set(\@sessions, { });
+  $self->set(\@INFO, { });
 
   my $alias = delete $parms{'alias'};
 
   POE::Session->create(
 		object_states => [
-		     $self => $self->{OBJECT_STATES_HASHREF},
-		     $self => $self->{OBJECT_STATES_ARRAYREF}, ],
+		     $self => $self->OBJECT_STATES_HASHREF,
+		     $self => $self->OBJECT_STATES_ARRAYREF, ],
 		( defined ( $parms{'options'} ) ? ( options => $parms{'options'} ) : () ),
 		args => [ $alias ],
 		heap => $self, );
@@ -1297,7 +1357,7 @@
 # The handler for all IRC commands that take no arguments.
 sub noargs {
   my ($kernel, $state, $arg) = @_[KERNEL, STATE, ARG0];
-  my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];
+  my $pri = $_[OBJECT]->IRC_CMDS()->{$state}->[CMD_PRI];
 
   if (defined $arg) {
     warn "The POE::Component::IRC event \"$state\" takes no arguments";
@@ -1312,7 +1372,7 @@
 sub oneandtwoopt {
   my ($kernel, $state) = @_[KERNEL, STATE];
   my $arg = join '', @_[ARG0 .. $#_];
-  my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];
+  my $pri = $_[OBJECT]->IRC_CMDS()->{$state}->[CMD_PRI];
 
   $state = 'connect' if $state eq 'sconnect';
   $state = uc $state;
@@ -1329,7 +1389,7 @@
 sub oneoptarg {
   my ($kernel, $state) = @_[KERNEL, STATE];
   my $arg = join '', @_[ARG0 .. $#_] if defined $_[ARG0];
-  my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];
+  my $pri = $_[OBJECT]->IRC_CMDS()->{$state}->[CMD_PRI];
 
   $state = uc $state;
   if (defined $arg) {
@@ -1345,7 +1405,7 @@
 sub oneortwo {
   my ($kernel, $state, $one) = @_[KERNEL, STATE, ARG0];
   my $two = join '', @_[ARG1 .. $#_];
-  my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];
+  my $pri = $_[OBJECT]->IRC_CMDS()->{$state}->[CMD_PRI];
 
   unless (defined $one) {
     warn "The POE::Component::IRC event \"$state\" requires at least one argument";
@@ -1363,7 +1423,7 @@
 sub onlyonearg {
   my ($kernel, $state) = @_[KERNEL, STATE];
   my $arg = join '', @_[ARG0 .. $#_];
-  my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];
+  my $pri = $_[OBJECT]->IRC_CMDS()->{$state}->[CMD_PRI];
 
   unless (defined $arg) {
     warn "The POE::Component::IRC event \"$state\" requires one argument";
@@ -1382,7 +1442,7 @@
 sub onlytwoargs {
   my ($kernel, $state, $one) = @_[KERNEL, STATE, ARG0];
   my ($two) = join '', @_[ARG1 .. $#_];
-  my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];
+  my $pri = $_[OBJECT]->IRC_CMDS()->{$state}->[CMD_PRI];
 
   unless (defined $one and defined $two) {
     warn "The POE::Component::IRC event \"$state\" requires two arguments";
@@ -1401,7 +1461,7 @@
 sub privandnotice {
   my ($kernel, $state, $to) = @_[KERNEL, STATE, ARG0];
   my $message = join ' ', @_[ARG1 .. $#_];
-  my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];
+  my $pri = $_[OBJECT]->IRC_CMDS()->{$state}->[CMD_PRI];
 
   $state =~ s/privmsglo/privmsg/;
   $state =~ s/privmsghi/privmsg/;
@@ -1447,9 +1507,9 @@
 
   foreach (@events) {
     $_ = "irc_" . $_ unless /^_/;
-    $self->{events}->{$_}->{$sender_id} = $sender_id;
-    $self->{sessions}->{$sender_id}->{'ref'} = $sender_id;
-    unless ($self->{sessions}->{$sender_id}->{refcnt}++ or $session_id == $sender_id) {
+    $self->events()->{$_}->{$sender_id} = $sender_id;
+    $self->sessions()->{$sender_id}->{'ref'} = $sender_id;
+    unless ($self->sessions()->{$sender_id}->{refcnt}++ or $session_id == $sender_id) {
       $kernel->refcount_increment($sender_id, PCI_REFCOUNT_TAG);
     }
   }
@@ -1474,9 +1534,9 @@
   # basic, dcc (implies ctcp), ctcp, oper ...what other categories?
   foreach (@events) {
     $_ = "irc_" . $_ unless /^_/;
-    $self->{events}->{$_}->{$sender_id} = $sender_id;
-    $self->{sessions}->{$sender_id}->{'ref'} = $sender_id;
-    unless ($self->{sessions}->{$sender_id}->{refcnt}++ or $session == $sender) {
+    $self->events()->{$_}->{$sender_id} = $sender_id;
+    $self->sessions()->{$sender_id}->{'ref'} = $sender_id;
+    unless ($self->sessions()->{$sender_id}->{refcnt}++ or $session == $sender) {
       $kernel->refcount_increment($sender_id, PCI_REFCOUNT_TAG);
     }
   }
@@ -1499,16 +1559,21 @@
   my $cmd = join ' ', 'QUIT', $args || '';
   $kernel->sig( 'POCOIRC_REGISTER' );
   $kernel->sig( 'POCOIRC_SHUTDOWN' );
-  $self->{_shutdown} = 1;
+  $self->set(\@_shutdown, 1);
   $self->_send_event( 'irc_shutdown', $_[SENDER]->ID() );
   $self->_unregister_sessions();
   $kernel->alarm_remove_all();
   $kernel->alias_remove( $_ ) for $kernel->alias_list( $_[SESSION] );
-  delete $self->{$_} for qw(sock socketfactory dcc wheelmap);
+  
+  $self->set(\@sock, undef);
+  $self->set(\@socketfactory, undef);
+  $self->set(\@dcc, undef);
+  $self->set(\@wheelmap, undef);
+  
   # Delete all plugins that are loaded.
   $self->plugin_del( $_ ) for keys %{ $self->plugin_list() };
-  $self->{resolver}->shutdown() if $self->{mydns} and $self->{resolver};
-  $kernel->call( $session, 'sl_high', $cmd ) if $self->{socket};
+  $self->resolver()->shutdown() if $self->mydns and $self->resolver;
+  $kernel->call( $session, 'sl_high', $cmd ) if $self->socket;
   undef;
 }
 
@@ -1564,29 +1629,29 @@
   }
 
   my $now = time();
-  $self->{send_time} = $now if $self->{send_time} < $now;
+  $self->set(\@send_time, $now) if $self->send_time < $now;
 
-  if (@{$self->{send_queue}}) {
-    my $i = @{$self->{send_queue}};
-    $i-- while ($i and $priority < $self->{send_queue}->[$i-1]->[MSG_PRI]);
-    splice( @{$self->{send_queue}}, $i, 0,
+  if (@{$self->_send_queue}) {
+    my $i = @{$self->_send_queue};
+    $i-- while ($i and $priority < $self->_send_queue->[$i-1]->[MSG_PRI]);
+    splice( @{$self->_send_queue}, $i, 0,
             [ $priority,  # MSG_PRI
               $msg,       # MSG_TEXT
             ]
           );
-  } elsif ( $self->{dont_flood} and
-            $self->{send_time} - $now >= 10 or not defined $self->{socket}
+  } elsif ( $self->dont_flood and
+            $self->send_time - $now >= 10 or not defined $self->socket
           ) {
-    push( @{$self->{send_queue}},
+    push( @{$self->_send_queue},
           [ $priority,  # MSG_PRI
             $msg,       # MSG_TEXT
 	   ]
 	 );
-    $kernel->delay( sl_delayed => $self->{send_time} - $now - 10 );
+    $kernel->delay( sl_delayed => $self->send_time - $now - 10 );
   } else {
-    warn ">>> $msg\n" if $self->{debug};
-    $self->{send_time} += 2 + length($msg) / 120;
-    $self->{socket}->put($msg);
+    warn ">>> $msg\n" if $self->_debug;
+    $self->set(\@send_time, $self->send_time + 2 + length($msg) / 120);
+    $self->socket()->put($msg);
   }
   undef;
 }
@@ -1598,20 +1663,20 @@
 sub sl_delayed {
   my ($kernel, $self) = @_[KERNEL, OBJECT];
 
-  return unless defined $self->{'socket'};
+  return unless defined $self->socket;
 
   my $now = time();
-  $self->{send_time} = $now if $self->{send_time} < $now;
+  $self->set(\@send_time, $now) if $self->send_time < $now;
 
-  while (@{$self->{send_queue}} and ($self->{send_time} - $now < 10)) {
-    my $arg = (shift @{$self->{send_queue}})->[MSG_TEXT];
-    warn ">>> $arg\n" if $self->{'debug'};
-    $self->{send_time} += 2 + length($arg) / 120;
-    $self->{'socket'}->put( "$arg" );
+  while (@{$self->_send_queue} and ($self->send_time - $now < 10)) {
+    my $arg = (shift @{$self->_send_queue})->[MSG_TEXT];
+    warn ">>> $arg\n" if $self->_debug;
+    $self->set(\@send_time, $self->send_time + 2 + length($arg) / 120);
+    $self->socket->put( "$arg" );
   }
 
-  $kernel->delay( sl_delayed => $self->{send_time} - $now - 10 )
-    if @{$self->{send_queue}};
+  $kernel->delay( sl_delayed => $self->send_time - $now - 10 )
+    if @{$self->_send_queue};
   undef;
 }
 
@@ -1620,7 +1685,7 @@
 sub spacesep {
   my ($kernel, $state) = @_[KERNEL, STATE];
   my $args = join ' ', @_[ARG0 .. $#_];
-  my $pri = $_[OBJECT]->{IRC_CMDS}->{$state}->[CMD_PRI];
+  my $pri = $_[OBJECT]->IRC_CMDS()->{$state}->[CMD_PRI];
 
   $state = uc $state;
   $state .= " $args" if defined $args;
@@ -1664,13 +1729,13 @@
 
   foreach (@_) {
     $_ = "irc_" . $_ unless /^_/;
-    my $blah = delete $self->{events}->{$_}->{$sender_id};
+    my $blah = delete $self->events()->{$_}->{$sender_id};
     unless ( $blah ) {
 	warn "$sender_id hasn't registered for '$_' events\n";
 	next;
     }
-    if (--$self->{sessions}->{$sender_id}->{refcnt} <= 0) {
-      delete $self->{sessions}->{$sender_id};
+    if (--$self->sessions()->{$sender_id}->{refcnt} <= 0) {
+      delete $self->sessions()->{$sender_id};
       unless ($session == $sender) {
         $poe_kernel->refcount_decrement($sender_id, PCI_REFCOUNT_TAG);
       }
@@ -1681,12 +1746,12 @@
 
 sub _unregister_sessions {
   my $self = shift;
-  foreach my $session_id ( keys %{ $self->{sessions} } ) {
-     my $refcnt = $self->{sessions}->{$session_id}->{refcnt};
+  foreach my $session_id ( keys %{ $self->sessions } ) {
+     my $refcnt = $self->sessions()->{$session_id}->{refcnt};
      while ( $refcnt --> 0 ) {
 	$poe_kernel->refcount_decrement($session_id, PCI_REFCOUNT_TAG) 
      }
-     delete $self->{sessions}->{$session_id};
+     delete $self->sessions()->{$session_id};
   }
 }
 
@@ -1716,37 +1781,30 @@
 
 sub server_name {
   my $self = shift;
-  return $self->{INFO}->{ServerName};
+  return $self->INFO()->{ServerName};
 }
 
 sub nick_name {
   my $self = shift;
-  return $self->{RealNick};
+  return $self->RealNick();
 }
 
-sub send_queue {
+sub session_alias {
   my $self = shift;
-  if ( defined ( $self->{send_queue} ) and ref ( $self->{send_queue} ) eq 'ARRAY' ) {
-	return scalar @{ $self->{send_queue} };
-  }
-  return 0;
+  return $self->alias();
 }
 
-sub raw_events {
-  my $self = shift;
-  my $value = shift;
-  return $self->{raw_events} unless defined $value;
-  $self->{raw_events} = $value;
-}
-
 sub session_id {
   my $self = shift;
-  return $self->{SESSION_ID};
+  return $self->SESSION_ID();
 }
 
-sub session_alias {
+sub send_queue {
   my $self = shift;
-  return $self->{alias};
+  if ( defined ( $self->_send_queue ) and ref ( $self->_send_queue ) eq 'ARRAY' ) {
+	return scalar @{ $self->_send_queue };
+  }
+  return 0;
 }
 
 sub yield {
@@ -1800,7 +1858,7 @@
   my $self = shift;
   my $cmd = lc ( $_[0] ) || return 0;
 
-  foreach my $command ( keys %{ $self->{IRC_CMDS} } ) {
+  foreach my $command ( keys %{ $self->IRC_CMDS() } ) {
 	if ( $cmd eq $command ) {
 		return 1;
 	}
@@ -1808,37 +1866,32 @@
   return 0;
 }
 
-sub connected {
-  my $self = shift;
-  return $self->{connected};
-}
-
 sub _compress_uplink {
   my ($self,$value) = splice @_, 0, 2;
-  return unless $self->{can_do_zlib};
-  return $self->{uplink} unless defined $value;
+  return unless $self->can_do_zlib;
+  return $self->uplink unless defined $value;
   if ( $value ) {
-	$self->{out_filter}->unshift( POE::Filter::Zlib::Stream->new() ) unless $self->{uplink};
-	$self->{uplink} = 1;
+	$self->out_filter()->unshift( POE::Filter::Zlib::Stream->new() ) unless $self->uplink;
+	$self->set(\@uplink, 1);
   } else {
-	$self->{out_filter}->shift() if $self->{uplink};
-	$self->{uplink} = 0;
+	$self->out_filter()->shift() if $self->uplink;
+	$self->set(\@uplink, 0);
   }
-  return $self->{uplink};
+  return $self->uplink;
 }
 
 sub _compress_downlink {
   my ($self,$value) = splice @_, 0, 2;
-  return unless $self->{can_do_zlib};
-  return $self->{downlink} unless defined $value;
+  return unless $self->can_do_zlib;
+  return $self->downlink unless defined $value;
   if ( $value ) {
-	$self->{srv_filter}->unshift( POE::Filter::Zlib::Stream->new() ) unless $self->{downlink};
-	$self->{downlink} = 1;
+	$self->srv_filter()->unshift( POE::Filter::Zlib::Stream->new() ) unless $self->downlink;
+	$self->set(\@downlink, 1);
   } else {
-	$self->{srv_filter}->shift() if $self->{uplink};
-	$self->{downlink} = 0;
+	$self->srv_filter()->shift() if $self->uplink;
+	$self->set(\@downlink, 0);
   }
-  return $self->{downlink};
+  return $self->downlink;
 }
 
 # Automatically replies to a PING from the server. Do not confuse this
@@ -1856,30 +1909,26 @@
   my ($self, $irc) = splice @_, 0, 2;
   my $nick = ( split /!/, ${ $_[0] } )[0];
   my $new = ${ $_[1] };
-  $self->{RealNick} = $new if ( $nick eq $self->{RealNick} );
+  $self->set(\@RealNick, $new) if ( $nick eq $self->RealNick );
   undef;
 }
 
 # accesses the ISupport plugin
 sub isupport {
   my ($self) = shift;
-  return $self->{isupport}->isupport(@_);
+  return $self->_isupport()->isupport(@_);
 }
 
 sub isupport_dump_keys {
-  return $_[0]->{isupport}->isupport_dump_keys();
+  return $_[0]->isupport()->isupport_dump_keys();
 }
 
-sub resolver {
-  return $_[0]->{resolver};
-}
-
 # accesses the plugin pipeline
 sub pipeline {
   my ($self) = @_;
-  $self->{PLUGINS} = POE::Component::IRC::Pipeline->new($self)
-    unless UNIVERSAL::isa($self->{PLUGINS}, 'POE::Component::IRC::Pipeline');
-  return $self->{PLUGINS};
+  $self->set(\@PLUGINS, POE::Component::IRC::Pipeline->new($self))
+    unless UNIVERSAL::isa($self->PLUGINS(), 'POE::Component::IRC::Pipeline');
+  return $self->PLUGINS;
 }
 
 # Adds a new plugin object
@@ -2037,10 +2086,10 @@
 
     if ( $plugin->can($sub) ) {
       eval { $ret = $plugin->$sub($self,@args) };
-      warn "$sub call failed with '$@'\n" if $@ and $self->{plugin_debug};
+      warn "$sub call failed with '$@'\n" if $@ and $self->plugin_debug;
     } elsif ( $plugin->can('_default') ) {
       eval { $ret = $plugin->_default($self,$sub,@args) };
-      warn "_default call failed with '$@'\n" if $@ and $self->{plugin_debug};
+      warn "_default call failed with '$@'\n" if $@ and $self->plugin_debug;
     }
 
     return $return if $ret == PCI_EAT_PLUGIN;
Index: IRC/Pipeline.pm
===================================================================
--- IRC/Pipeline.pm	(revision 296)
+++ IRC/Pipeline.pm	(working copy)
@@ -14,7 +14,7 @@
     PIPELINE => [],
     HANDLES => {},
     IRC => $irc,
-    DEBUG => $irc->{plugin_debug},
+    DEBUG => $irc->plugin_debug,
   }, $class;
 }
 
Index: IRC/Qnet.pm
===================================================================
--- IRC/Qnet.pm	(revision 296)
+++ IRC/Qnet.pm	(working copy)
@@ -14,10 +14,13 @@
 use Carp;
 use POE qw(Component::IRC::Constants);
 use vars qw($VERSION);
-use base qw(POE::Component::IRC);
 
 $VERSION = '1.3';
 
+use Object::InsideOut 'POE::Component::IRC';
+
+my @service_bots :Field :Acc(service_bots) :Type(HASH);
+
 sub _create {
   my $self = shift;
 
@@ -85,11 +88,13 @@
         requestowner
         );
 
-  $self->{OBJECT_STATES_HASHREF}->{'qbot_' . $_} = '_qnet_bot_commands' for @qbot_commands;
-  $self->{OBJECT_STATES_HASHREF}->{'lbot_' . $_} = '_qnet_bot_commands' for @lbot_commands;
-  $self->{server} = 'irc.quakenet.org';
-  $self->{QBOT} = 'Q@Cserve.quakenet.org';
-  $self->{LBOT} = 'L@lightweight.quakenet.org';
+  $self->OBJECT_STATES_HASHREF()->{'qbot_' . $_} = '_qnet_bot_commands' for @qbot_commands;
+  $self->OBJECT_STATES_HASHREF()->{'lbot_' . $_} = '_qnet_bot_commands' for @lbot_commands;
+  $self->server('irc.quakenet.org');
+  $self->set(\@service_bots, {
+    QBOT => 'Q@Cserve.quakenet.org',
+    LBOT => 'L@lightweight.quakenet.org',
+  });
 
   return 1;
 }
@@ -97,29 +102,15 @@
 sub _qnet_bot_commands {
   my ($kernel, $state, $self) = @_[KERNEL,STATE,OBJECT];
   my $message = join ' ', @_[ARG0 .. $#_];
-  my $pri = $self->{IRC_CMDS}->{'privmsghi'}->[CMD_PRI];
+  my $pri = $self->IRC_CMDS()->{'privmsghi'}->[CMD_PRI];
   my $command = "PRIVMSG ";
   my ($target,$cmd) = split(/_/,$state);
-  $command .= join(' :',$self->{uc $target},uc($cmd));
+  $command .= join(' :',$self->service_bots()->{uc $target},uc($cmd));
   $command = join(' ',$command,$message) if defined ( $message );
   $kernel->yield( 'sl_prioritized', $pri, $command );
   undef;
 }
 
-sub service_bots {
-  my $self = shift;
-  croak "Method requires an even number of parameters" if @_ % 2;
-
-  my (%args) = @_;
-
-  foreach my $botname ( qw(QBOT LBOT) ) {
-	if ( defined ( $args{$botname} ) ) {
-		$self->{$botname} = $args{$botname};
-	}
-  }
-  return 1;
-}
-
 1;
 __END__
 
Index: IRC/Qnet/State.pm
===================================================================
--- IRC/Qnet/State.pm	(revision 296)
+++ IRC/Qnet/State.pm	(working copy)
@@ -16,10 +16,14 @@
 use POE::Component::IRC::Common qw(:ALL);
 use POE::Component::IRC::Plugin qw(:ALL);
 use vars qw($VERSION);
-use base qw(POE::Component::IRC::State POE::Component::IRC::Qnet);
 
 $VERSION = '1.8';
 
+use Object::InsideOut qw(POE::Component::IRC::State POE::Component::IRC::Qnet);
+
+my @whois :Field :Acc(WHOIS);
+my @user_authed :Field :Acc(USER_AUTHED);
+
 sub _create {
   my $self = shift;
 
@@ -86,15 +90,10 @@
         welcome
         requestowner
         );
+	
+  $self->OBJECT_STATES_HASHREF()->{'resync_chan'} = '_resync_chan';
+  $self->OBJECT_STATES_HASHREF()->{'resync_nick'} = '_resync_nick';
 
-  $self->{OBJECT_STATES_HASHREF}->{'qbot_' . $_} = '_qnet_bot_commands' for @qbot_commands;
-  $self->{OBJECT_STATES_HASHREF}->{'lbot_' . $_} = '_qnet_bot_commands' for @lbot_commands;
-  $self->{OBJECT_STATES_HASHREF}->{'resync_chan'} = '_resync_chan';
-  $self->{OBJECT_STATES_HASHREF}->{'resync_nick'} = '_resync_nick';
-  $self->{server} = 'irc.quakenet.org';
-  $self->{QBOT} = 'Q@Cserve.quakenet.org';
-  $self->{LBOT} = 'L@lightweight.quakenet.org';
-
   return 1;
 }
 
@@ -106,9 +105,9 @@
   foreach my $channel ( @channels ) {
 	next unless $self->is_channel_member( $channel, $nickname );
   	my $uchan = u_irc $channel, $mapping;
-	delete $self->{STATE}->{Chans}->{ $uchan };
-	$self->{CHANNEL_SYNCH}->{ $uchan } = { MODE => 0, WHO => 0, BAN => 0, _time => time() };
-        $self->{STATE}->{Chans}->{ $uchan } = { Name => $channel, Mode => '' };
+	delete $self->STATE()->{Chans}->{ $uchan };
+	$self->CHANNEL_SYNCH()->{ $uchan } = { MODE => 0, WHO => 0, BAN => 0, _time => time() };
+        $self->STATE()->{Chans}->{ $uchan } = { Name => $channel, Mode => '' };
         $self->yield ( 'sl' => "WHO $channel $flags,101" );
         $self->yield ( 'mode' => $channel );
         $self->yield ( 'mode' => $channel => 'b');
@@ -130,12 +129,12 @@
 	next unless $self->is_channel_member( $channel, $nick );
   	my $uchan = u_irc $channel, $mapping;
         $self->yield ( 'sl' => "WHO $nick $flags,102" );
-        $self->{STATE}->{Nicks}->{ $unick }->{Nick} = $nick;
-        $self->{STATE}->{Nicks}->{ $unick }->{User} = $user;
-        $self->{STATE}->{Nicks}->{ $unick }->{Host} = $host;
-        $self->{STATE}->{Nicks}->{ $unick }->{CHANS}->{ $uchan } = '';
-        $self->{STATE}->{Chans}->{ $uchan }->{Nicks}->{ $unick } = '';
-	push @{ $self->{NICK_SYNCH}->{ $unick } }, $channel;
+        $self->STATE()->{Nicks}->{ $unick }->{Nick} = $nick;
+        $self->STATE()->{Nicks}->{ $unick }->{User} = $user;
+        $self->STATE()->{Nicks}->{ $unick }->{Host} = $host;
+        $self->STATE()->{Nicks}->{ $unick }->{CHANS}->{ $uchan } = '';
+        $self->STATE()->{Chans}->{ $uchan }->{Nicks}->{ $unick } = '';
+	push @{ $self->NICK_SYNCH()->{ $unick } }, $channel;
   }
   undef;
 }
@@ -145,7 +144,7 @@
   my ($self,$irc) = splice @_, 0, 2;
   my ($nick,$account) = ( split / /, ${ $_[1] } )[0..1];
 
-  $self->{WHOIS}->{ $nick }->{account} = $account;
+  $self->WHOIS()->{ $nick }->{account} = $account;
   return PCI_EAT_NONE;
 }
 
@@ -157,26 +156,26 @@
   my $unick = u_irc $nick, $mapping;
   my $uchan = u_irc $channel, $mapping;
   
-  $self->{STATE}->{Nicks}->{ $unick }->{Nick} = $nick;
-  $self->{STATE}->{Nicks}->{ $unick }->{User} = $user;
-  $self->{STATE}->{Nicks}->{ $unick }->{Host} = $host;
-  $self->{STATE}->{Nicks}->{ $unick }->{Real} = $real;
-  $self->{STATE}->{Nicks}->{ $unick }->{Server} = $server;
-  $self->{STATE}->{Nicks}->{ $unick }->{Auth} = $auth if ( $auth );
-  if ( $auth and defined ( $self->{USER_AUTHED}->{ $unick } ) ) {
-	$self->{USER_AUTHED}->{ $unick } = $auth;
+  $self->STATE()->{Nicks}->{ $unick }->{Nick} = $nick;
+  $self->STATE()->{Nicks}->{ $unick }->{User} = $user;
+  $self->STATE()->{Nicks}->{ $unick }->{Host} = $host;
+  $self->STATE()->{Nicks}->{ $unick }->{Real} = $real;
+  $self->STATE()->{Nicks}->{ $unick }->{Server} = $server;
+  $self->STATE()->{Nicks}->{ $unick }->{Auth} = $auth if ( $auth );
+  if ( $auth and defined ( $self->USER_AUTHED()->{ $unick } ) ) {
+	$self->USER_AUTHED()->{ $unick } = $auth;
   }
   if ( $query eq '101' ) {
     my $whatever = '';
     if ( $status =~ /\@/ ) { $whatever .= 'o'; }
     if ( $status =~ /\+/ ) { $whatever .= 'v'; }
     if ( $status =~ /\%/ ) { $whatever .= 'h'; }
-    $self->{STATE}->{Nicks}->{ $unick }->{CHANS}->{ $uchan } = $whatever;
-    $self->{STATE}->{Chans}->{ $uchan }->{Name} = $channel;
-    $self->{STATE}->{Chans}->{ $uchan }->{Nicks}->{ $unick } = $whatever;
+    $self->STATE()->{Nicks}->{ $unick }->{CHANS}->{ $uchan } = $whatever;
+    $self->STATE()->{Chans}->{ $uchan }->{Name} = $channel;
+    $self->STATE()->{Chans}->{ $uchan }->{Nicks}->{ $unick } = $whatever;
   }
   if ( $status =~ /\*/ ) {
-    $self->{STATE}->{Nicks}->{ $unick }->{IRCop} = 1;
+    $self->STATE()->{Nicks}->{ $unick }->{IRCop} = 1;
   }
   return PCI_EAT_NONE;
 }
@@ -191,16 +190,16 @@
   # If it begins with #, &, + or ! its a channel apparently. RFC2812.
   if ( $channel =~ /^[\x23\x2B\x21\x26]/ ) {
     if ( $self->_channel_sync($channel, 'WHO' ) ) {
-        my $rec = delete $self->{CHANNEL_SYNCH}->{ $uchan };
+        my $rec = delete $self->CHANNEL_SYNCH()->{ $uchan };
         $self->_send_event( 'irc_chan_sync', $channel, time() - $rec->{_time} );
     }
   # Otherwise we assume its a nickname
   } else {
-	if ( defined $self->{USER_AUTHED}->{ $uchan } ) {
-	   $self->_send_event( 'irc_nick_authed', $channel, delete $self->{USER_AUTHED}->{ $uchan } );
+	if ( defined $self->USER_AUTHED()->{ $uchan } ) {
+	   $self->_send_event( 'irc_nick_authed', $channel, delete $self->USER_AUTHED()->{ $uchan } );
 	} else {
-	   my $chan = shift @{ $self->{NICK_SYNCH}->{ $uchan } };
-	   delete $self->{NICK_SYNCH}->{ $uchan } unless scalar @{ $self->{NICK_SYNCH}->{ $uchan } };
+	   my $chan = shift @{ $self->NICK_SYNCH()->{ $uchan } };
+	   delete $self->NICK_SYNCH()->{ $uchan } unless scalar @{ $self->NICK_SYNCH()->{ $uchan } };
            $self->_send_event( 'irc_nick_sync', $channel, $chan );
 	}
   }
@@ -220,21 +219,21 @@
   my $flags = '%cunharsft';
 
   if ( $unick eq u_irc ( $self->nick_name(), $mapping ) ) {
-	delete $self->{STATE}->{Chans}->{ $uchan };
-	$self->{CHANNEL_SYNCH}->{ $uchan } = { MODE => 0, WHO => 0, BAN => 0, _time => time() };
-        $self->{STATE}->{Chans}->{ $uchan } = { Name => $channel, Mode => '' };
+	delete $self->STATE()->{Chans}->{ $uchan };
+	$self->CHANNEL_SYNCH()->{ $uchan } = { MODE => 0, WHO => 0, BAN => 0, _time => time() };
+        $self->STATE()->{Chans}->{ $uchan } = { Name => $channel, Mode => '' };
         $self->yield ( 'sl' => "WHO $channel $flags,101" );
         $self->yield ( 'mode' => $channel );
         $self->yield ( 'mode' => $channel => 'b');
 
   } else {
         $self->yield ( 'sl' => "WHO $nick $flags,102" );
-        $self->{STATE}->{Nicks}->{ $unick }->{Nick} = $nick;
-        $self->{STATE}->{Nicks}->{ $unick }->{User} = $user;
-        $self->{STATE}->{Nicks}->{ $unick }->{Host} = $host;
-        $self->{STATE}->{Nicks}->{ $unick }->{CHANS}->{ $uchan } = '';
-        $self->{STATE}->{Chans}->{ $uchan }->{Nicks}->{ $unick } = '';
-	push @{ $self->{NICK_SYNCH}->{ $unick } }, $channel;
+        $self->STATE()->{Nicks}->{ $unick }->{Nick} = $nick;
+        $self->STATE()->{Nicks}->{ $unick }->{User} = $user;
+        $self->STATE()->{Nicks}->{ $unick }->{Host} = $host;
+        $self->STATE()->{Nicks}->{ $unick }->{CHANS}->{ $uchan } = '';
+        $self->STATE()->{Chans}->{ $uchan }->{Nicks}->{ $unick } = '';
+	push @{ $self->NICK_SYNCH()->{ $unick } }, $channel;
   }
   return PCI_EAT_NONE;
 }
@@ -248,8 +247,8 @@
   my $arg = ${ $_[3] };
   my $uarg = u_irc $arg, $mapping;
   return PCI_EAT_NONE unless $source =~ /^[QL]$/ and $mode =~ /[ov]/;
-  if ( !$self->is_nick_authed($arg) and !$self->{USER_AUTHED}->{ $uarg } ) {
-	   $self->{USER_AUTHED}->{ $uarg } = 0;
+  if ( !$self->is_nick_authed($arg) and !$self->USER_AUTHED()->{ $uarg } ) {
+	   $self->USER_AUTHED()->{ $uarg } = 0;
 	   $self->yield ( 'sl' => "WHO $arg " . '%cunharsft,102' );
   }
   return PCI_EAT_NONE;
@@ -269,20 +268,20 @@
   }
 
   if ( $nick eq u_irc ( $self->nick_name(), $mapping ) ) {
-        delete $self->{STATE}->{Nicks}->{ $nick }->{CHANS}->{ $channel };
-        delete $self->{STATE}->{Chans}->{ $channel }->{Nicks}->{ $nick };
-        foreach my $member ( keys %{ $self->{STATE}->{Chans}->{ $channel }->{Nicks} } ) {
-           delete $self->{STATE}->{Nicks}->{ $member }->{CHANS}->{ $channel };
-           if ( scalar keys %{ $self->{STATE}->{Nicks}->{ $member }->{CHANS} } <= 0 ) {
-                delete $self->{STATE}->{Nicks}->{ $member };
+        delete $self->STATE()->{Nicks}->{ $nick }->{CHANS}->{ $channel };
+        delete $self->STATE()->{Chans}->{ $channel }->{Nicks}->{ $nick };
+        foreach my $member ( keys %{ $self->STATE()->{Chans}->{ $channel }->{Nicks} } ) {
+           delete $self->STATE()->{Nicks}->{ $member }->{CHANS}->{ $channel };
+           if ( scalar keys %{ $self->STATE()->{Nicks}->{ $member }->{CHANS} } <= 0 ) {
+                delete $self->STATE()->{Nicks}->{ $member };
            }
         }
-	delete $self->{STATE}->{Chans}->{ $channel };
+	delete $self->STATE()->{Chans}->{ $channel };
   } else {
-        delete $self->{STATE}->{Nicks}->{ $nick }->{CHANS}->{ $channel };
-        delete $self->{STATE}->{Chans}->{ $channel }->{Nicks}->{ $nick };
-        if ( scalar keys %{ $self->{STATE}->{Nicks}->{ $nick }->{CHANS} } <= 0 ) {
-                delete $self->{STATE}->{Nicks}->{ $nick };
+        delete $self->STATE()->{Nicks}->{ $nick }->{CHANS}->{ $channel };
+        delete $self->STATE()->{Chans}->{ $channel }->{Nicks}->{ $nick };
+        if ( scalar keys %{ $self->STATE()->{Nicks}->{ $nick }->{CHANS} } <= 0 ) {
+                delete $self->STATE()->{Nicks}->{ $nick };
         }
   }
   return PCI_EAT_NONE;
@@ -309,12 +308,12 @@
   }
 
   if ( $unick eq u_irc ( $self->nick_name(), $mapping ) ) {
-        delete $self->{STATE};
+        $self->reset_state();
   } else {
         foreach my $channel ( keys %{ $self->{STATE}->{Nicks}->{ $unick }->{CHANS} } ) {
-                delete $self->{STATE}->{Chans}->{ $channel }->{Nicks}->{ $unick };
+                delete $self->STATE()->{Chans}->{ $channel }->{Nicks}->{ $unick };
         }
-        delete $self->{STATE}->{Nicks}->{ $unick };
+        delete $self->STATE()->{Nicks}->{ $unick };
   }
   return PCI_EAT_NONE;
 }
@@ -331,20 +330,20 @@
   my $uchan = u_irc $channel, $mapping;
 
   if ( $unick eq u_irc ( $self->nick_name(), $mapping ) ) {
-        delete $self->{STATE}->{Nicks}->{ $unick }->{CHANS}->{ $uchan };
-        delete $self->{STATE}->{Chans}->{ $uchan }->{Nicks}->{ $unick };
-        foreach my $member ( keys %{ $self->{STATE}->{Chans}->{ $uchan }->{Nicks} } ) {
-           delete $self->{STATE}->{Nicks}->{ $member }->{CHANS}->{ $uchan };
-           if ( scalar keys %{ $self->{STATE}->{Nicks}->{ $member }->{CHANS} } <= 0 ) {
-                delete $self->{STATE}->{Nicks}->{ $member };
+        delete $self->STATE()->{Nicks}->{ $unick }->{CHANS}->{ $uchan };
+        delete $self->STATE()->{Chans}->{ $uchan }->{Nicks}->{ $unick };
+        foreach my $member ( keys %{ $self->STATE()->{Chans}->{ $uchan }->{Nicks} } ) {
+           delete $self->STATE()->{Nicks}->{ $member }->{CHANS}->{ $uchan };
+           if ( scalar keys %{ $self->STATE()->{Nicks}->{ $member }->{CHANS} } <= 0 ) {
+                delete $self->STATE()->{Nicks}->{ $member };
            }
         }
-	delete $self->{STATE}->{Chans}->{ $uchan };
+	delete $self->STATE()->{Chans}->{ $uchan };
   } else {
-        delete $self->{STATE}->{Nicks}->{ $unick }->{CHANS}->{ $uchan };
-        delete $self->{STATE}->{Chans}->{ $uchan }->{Nicks}->{ $unick };
-        if ( scalar keys %{ $self->{STATE}->{Nicks}->{ $unick }->{CHANS} } <= 0 ) {
-                delete $self->{STATE}->{Nicks}->{ $unick };
+        delete $self->STATE()->{Nicks}->{ $unick }->{CHANS}->{ $uchan };
+        delete $self->STATE()->{Chans}->{ $uchan }->{Nicks}->{ $unick };
+        if ( scalar keys %{ $self->STATE()->{Nicks}->{ $unick }->{CHANS} } <= 0 ) {
+                delete $self->STATE()->{Nicks}->{ $unick };
         }
   }
   return PCI_EAT_NONE;
@@ -355,7 +354,7 @@
   my $mapping = $self->isupport('CASEMAPPING');
   my $nick = u_irc ( $_[0], $mapping ) || return;
   return unless $self->_nick_exists($nick);
-  return $self->{STATE}->{Nicks}->{ $nick }->{Auth} 
+  return $self->STATE()->{Nicks}->{ $nick }->{Auth} 
 	if defined $self->{STATE}->{Nicks}->{ $nick }->{Auth};
   return;
 }
@@ -366,8 +365,8 @@
   my $chan = shift || return;
   return unless _channel_exists( $chan );
   my @results;
-  foreach my $nick ( keys %{ $self->{STATE}->{Chans}->{ $chan }->{Nicks} } ) {
-    push @results, $self->{STATE}->{Nicks}->{ $nick }->{Nick} if defined ( $self->{STATE}->{Nicks}->{ $nick }->{Auth} ) and $self->{STATE}->{Nicks}->{ $nick }->{Auth} eq $auth;
+  foreach my $nick ( keys %{ $self->STATE()->{Chans}->{ $chan }->{Nicks} } ) {
+    push @results, $self->STATE()->{Nicks}->{ $nick }->{Nick} if defined ( $self->STATE()->{Nicks}->{ $nick }->{Auth} ) and $self->STATE()->{Nicks}->{ $nick }->{Auth} eq $auth;
   }
   return @results; 
 }
Index: IRC/State.pm
===================================================================
--- IRC/State.pm	(revision 296)
+++ IRC/State.pm	(working copy)
@@ -13,7 +13,6 @@
 use warnings;
 use POE::Component::IRC::Common qw(:ALL);
 use POE::Component::IRC::Plugin qw(:ALL);
-use base qw(POE::Component::IRC);
 use vars qw($VERSION);
 
 $VERSION = '2.3';
@@ -21,41 +20,65 @@
 # Event handlers for tracking the STATE. $self->{STATE} is used as our namespace.
 # u_irc() is used to create unique keys.
 
+use Object::InsideOut 'POE::Component::IRC';
+
+my @state :Field :Acc(Name => 'STATE', Restricted => 1);
+my @nick_synch :Field :Acc(Name => 'NICK_SYNCH', Restricted => 1);
+my @channel_synch :Field :Acc(Name => 'CHANNEL_SYNCH', Restricted => 1);
+
+sub init :Init {
+  my $self = shift;
+  
+  $self->reset_state();
+  $self->set(\@nick_synch, { });
+  $self->set(\@channel_synch, { });
+}
+
+sub reset_state {
+  my $self = shift;
+  
+  $self->set(\@state, {
+    Nicks => { },
+    Chans => { },
+    Modes => { },
+  });
+}
+
 # Make sure we have a clean STATE when we first join the network and if we inadvertently get disconnected
-sub S_001 {
-  delete $_[0]->{STATE};
+sub S_001 :Cumulative {
+  $_[0]->reset_state();
   return PCI_EAT_NONE;
 }
 
-sub S_disconnected {
+sub S_disconnected :Cumulative {
   my $self = shift;
-  my $nickinfo = $self->nick_info( $self->{RealNick} );
+  my $nickinfo = $self->nick_info( $self->RealNick );
   my $channels = $self->channels();
   push @{ $_[$#_] }, $nickinfo, $channels;
-  delete $self->{STATE};
+  $self->reset_state();
   return PCI_EAT_NONE;
 }
 
-sub S_error {
+sub S_error :Cumulative {
   my $self = shift;
-  my $nickinfo = $self->nick_info( $self->{RealNick} );
+  my $nickinfo = $self->nick_info( $self->RealNick );
   my $channels = $self->channels();
   push @{ $_[$#_] }, $nickinfo, $channels;
-  delete $self->{STATE};
+  $self->reset_state();
   return PCI_EAT_NONE;
 }
 
-sub S_socketerr {
+sub S_socketerr :Cumulative {
   my $self = shift;
-  my $nickinfo = $self->nick_info( $self->{RealNick} );
+  my $nickinfo = $self->nick_info( $self->RealNick() );
   my $channels = $self->channels();
   push @{ $_[$#_] }, $nickinfo, $channels;
-  delete $self->{STATE};
+  $self->reset_state();
   return PCI_EAT_NONE;
 }
 
 # Channel JOIN messages
-sub S_join {
+sub S_join :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   my $nick = ( split /!/, ${ $_[0] } )[0];
@@ -66,54 +89,54 @@
   my $unick = u_irc $nick, $mapping;
 
   if ( $unick eq u_irc ( $self->nick_name(), $mapping ) ) {
-	delete $self->{STATE}->{Chans}->{ $uchan };
-	$self->{CHANNEL_SYNCH}->{ $uchan } = { MODE => 0, WHO => 0, BAN => 0, _time => time() };
-        $self->{STATE}->{Chans}->{ $uchan } = { Name => $channel, Mode => '' };
+	delete $self->STATE()->{Chans}->{ $uchan };
+	$self->CHANNEL_SYNCH()->{ $uchan } = { MODE => 0, WHO => 0, BAN => 0, _time => time() };
+        $self->STATE()->{Chans}->{ $uchan } = { Name => $channel, Mode => '' };
         $self->yield ( 'who' => $channel );
         $self->yield ( 'mode' => $channel );
         $self->yield ( 'mode' => $channel => 'b');
 
   } else {
         $self->yield ( 'who' => $nick );
-        $self->{STATE}->{Nicks}->{ $unick }->{Nick} = $nick;
-        $self->{STATE}->{Nicks}->{ $unick }->{User} = $user;
-        $self->{STATE}->{Nicks}->{ $unick }->{Host} = $host;
-        $self->{STATE}->{Nicks}->{ $unick }->{CHANS}->{ $uchan } = '';
-        $self->{STATE}->{Chans}->{ $uchan }->{Nicks}->{ $unick } = '';
-	push @{ $self->{NICK_SYNCH}->{ $unick } }, $channel;
+        $self->STATE()->{Nicks}->{ $unick }->{Nick} = $nick;
+        $self->STATE()->{Nicks}->{ $unick }->{User} = $user;
+        $self->STATE()->{Nicks}->{ $unick }->{Host} = $host;
+        $self->STATE()->{Nicks}->{ $unick }->{CHANS}->{ $uchan } = '';
+        $self->STATE()->{Chans}->{ $uchan }->{Nicks}->{ $unick } = '';
+	push @{ $self->NICK_SYNCH()->{ $unick } }, $channel;
   }
   return PCI_EAT_NONE;
 }
 
 # Channel PART messages
-sub S_part {
+sub S_part :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   my $nick = u_irc ( ( split /!/, ${ $_[0] } )[0], $mapping );
   my $channel = u_irc ${ $_[1] }, $mapping;
 
   if ( $nick eq u_irc ( $self->nick_name(), $mapping ) ) {
-        delete $self->{STATE}->{Nicks}->{ $nick }->{CHANS}->{ $channel };
-        delete $self->{STATE}->{Chans}->{ $channel }->{Nicks}->{ $nick };
-        foreach my $member ( keys %{ $self->{STATE}->{Chans}->{ $channel }->{Nicks} } ) {
-           delete $self->{STATE}->{Nicks}->{ $member }->{CHANS}->{ $channel };
-           if ( scalar keys %{ $self->{STATE}->{Nicks}->{ $member }->{CHANS} } <= 0 ) {
-                delete $self->{STATE}->{Nicks}->{ $member };
+        delete $self->STATE()->{Nicks}->{ $nick }->{CHANS}->{ $channel };
+        delete $self->STATE()->{Chans}->{ $channel }->{Nicks}->{ $nick };
+        foreach my $member ( keys %{ $self->STATE()->{Chans}->{ $channel }->{Nicks} } ) {
+           delete $self->STATE()->{Nicks}->{ $member }->{CHANS}->{ $channel };
+           if ( scalar keys %{ $self->STATE()->{Nicks}->{ $member }->{CHANS} } <= 0 ) {
+                delete $self->STATE()->{Nicks}->{ $member };
            }
         }
-	delete $self->{STATE}->{Chans}->{ $channel };
+	delete $self->STATE()->{Chans}->{ $channel };
   } else {
-        delete $self->{STATE}->{Nicks}->{ $nick }->{CHANS}->{ $channel };
-        delete $self->{STATE}->{Chans}->{ $channel }->{Nicks}->{ $nick };
-        if ( scalar keys %{ $self->{STATE}->{Nicks}->{ $nick }->{CHANS} } <= 0 ) {
-                delete $self->{STATE}->{Nicks}->{ $nick };
+        delete $self->STATE()->{Nicks}->{ $nick }->{CHANS}->{ $channel };
+        delete $self->STATE()->{Chans}->{ $channel }->{Nicks}->{ $nick };
+        if ( scalar keys %{ $self->STATE()->{Nicks}->{ $nick }->{CHANS} } <= 0 ) {
+                delete $self->STATE()->{Nicks}->{ $nick };
         }
   }
   return PCI_EAT_NONE;
 }
 
 # QUIT messages
-sub S_quit {
+sub S_quit :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   my $nick = ( split /!/, ${ $_[0] } )[0];
@@ -132,18 +155,18 @@
   }
 
   if ( $unick eq u_irc ( $self->nick_name(), $mapping ) ) {
-        delete $self->{STATE};
+        $self->reset_state();
   } else {
-        foreach my $channel ( keys %{ $self->{STATE}->{Nicks}->{ $unick }->{CHANS} } ) {
-                delete $self->{STATE}->{Chans}->{ $channel }->{Nicks}->{ $unick };
+        foreach my $channel ( keys %{ $self->STATE()->{Nicks}->{ $unick }->{CHANS} } ) {
+                delete $self->STATE()->{Chans}->{ $channel }->{Nicks}->{ $unick };
         }
-        delete $self->{STATE}->{Nicks}->{ $unick };
+        delete $self->STATE()->{Nicks}->{ $unick };
   }
   return PCI_EAT_NONE;
 }
 
 # Channel KICK messages
-sub S_kick {
+sub S_kick :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   my $channel = ${ $_[1] };
@@ -153,27 +176,27 @@
   my $uchan = u_irc $channel, $mapping;
 
   if ( $unick eq u_irc ( $self->nick_name(), $mapping ) ) {
-        delete $self->{STATE}->{Nicks}->{ $unick }->{CHANS}->{ $uchan };
-        delete $self->{STATE}->{Chans}->{ $uchan }->{Nicks}->{ $unick };
-        foreach my $member ( keys %{ $self->{STATE}->{Chans}->{ $uchan }->{Nicks} } ) {
-           delete $self->{STATE}->{Nicks}->{ $member }->{CHANS}->{ $uchan };
-           if ( scalar keys %{ $self->{STATE}->{Nicks}->{ $member }->{CHANS} } <= 0 ) {
-                delete $self->{STATE}->{Nicks}->{ $member };
+        delete $self->STATE()->{Nicks}->{ $unick }->{CHANS}->{ $uchan };
+        delete $self->STATE()->{Chans}->{ $uchan }->{Nicks}->{ $unick };
+        foreach my $member ( keys %{ $self->STATE()->{Chans}->{ $uchan }->{Nicks} } ) {
+           delete $self->STATE()->{Nicks}->{ $member }->{CHANS}->{ $uchan };
+           if ( scalar keys %{ $self->STATE()->{Nicks}->{ $member }->{CHANS} } <= 0 ) {
+                delete $self->STATE()->{Nicks}->{ $member };
            }
         }
-	delete $self->{STATE}->{Chans}->{ $uchan };
+	delete $self->STATE()->{Chans}->{ $uchan };
   } else {
-        delete $self->{STATE}->{Nicks}->{ $unick }->{CHANS}->{ $uchan };
-        delete $self->{STATE}->{Chans}->{ $uchan }->{Nicks}->{ $unick };
-        if ( scalar keys %{ $self->{STATE}->{Nicks}->{ $unick }->{CHANS} } <= 0 ) {
-                delete $self->{STATE}->{Nicks}->{ $unick };
+        delete $self->STATE()->{Nicks}->{ $unick }->{CHANS}->{ $uchan };
+        delete $self->STATE()->{Chans}->{ $uchan }->{Nicks}->{ $unick };
+        if ( scalar keys %{ $self->STATE()->{Nicks}->{ $unick }->{CHANS} } <= 0 ) {
+                delete $self->STATE()->{Nicks}->{ $unick };
         }
   }
   return PCI_EAT_NONE;
 }
 
 # NICK changes
-sub S_nick {
+sub S_nick :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   my $nick = ( split /!/, ${ $_[0] } )[0];
@@ -182,24 +205,24 @@
   my $unick = u_irc $nick, $mapping;
   my $unew = u_irc $new, $mapping;
 
-  $self->{RealNick} = $new if $nick eq $self->{RealNick};
+  $self->RealNick($new) if $nick eq $self->RealNick;
 
   if ( $unick eq $unew ) {
         # Case Change
-        $self->{STATE}->{Nicks}->{ $unick }->{Nick} = $new;
+        $self->STATE()->{Nicks}->{ $unick }->{Nick} = $new;
   } else {
-        my $record = delete $self->{STATE}->{Nicks}->{ $unick };
+        my $record = delete $self->STATE()->{Nicks}->{ $unick };
         $record->{Nick} = $new;
         foreach my $channel ( keys %{ $record->{CHANS} } ) {
-           $self->{STATE}->{Chans}->{ $channel }->{Nicks}->{ $unew } = $record->{CHANS}->{ $channel };
-           delete $self->{STATE}->{Chans}->{ $channel }->{Nicks}->{ $unick };
+           $self->STATE()->{Chans}->{ $channel }->{Nicks}->{ $unew } = $record->{CHANS}->{ $channel };
+           delete $self->STATE()->{Chans}->{ $channel }->{Nicks}->{ $unick };
         }
-        $self->{STATE}->{Nicks}->{ $unew } = $record;
+        $self->STATE()->{Nicks}->{ $unew } = $record;
   }
   return PCI_EAT_NONE;
 }
 
-sub S_chan_mode {
+sub S_chan_mode :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   my $who = ${ $_[0] };
@@ -217,7 +240,7 @@
 }
 
 # Channel MODE
-sub S_mode {
+sub S_mode :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   my $who = ${ $_[0] };
@@ -234,7 +257,7 @@
   my $alwaysarg = join '', $statmodes,  @{ $chanmodes }[0 .. 1];
 
   # Do nothing if it is UMODE
-  if ( $uchan ne u_irc ( $self->{RealNick}, $mapping ) ) {
+  if ( $uchan ne u_irc ( $self->RealNick(), $mapping ) ) {
      my $parsed_mode = parse_mode_line( $prefix, $chanmodes, @modes );
      while ( my $mode = shift ( @{ $parsed_mode->{modes} } ) ) {
         my $arg;
@@ -246,72 +269,72 @@
           if ( $mode =~ /\+([$statmodes])/ ) {
                 my $flag = $1;
 		$arg = u_irc $arg, $mapping;
-                unless ($self->{STATE}->{Nicks}->{ $arg }->{CHANS}->{ $uchan }and $self->{STATE}->{Nicks}->{ $arg }->{CHANS}->{ $uchan } =~ /$flag/) {
-                      $self->{STATE}->{Nicks}->{ $arg }->{CHANS}->{ $uchan } .= $flag;
-                      $self->{STATE}->{Chans}->{ $uchan }->{Nicks}->{ $arg } = $self->{STATE}->{Nicks}->{ $arg }->{CHANS}->{ $uchan };
+                unless ($self->STATE()->{Nicks}->{ $arg }->{CHANS}->{ $uchan }and $self->STATE()->{Nicks}->{ $arg }->{CHANS}->{ $uchan } =~ /$flag/) {
+                      $self->STATE()->{Nicks}->{ $arg }->{CHANS}->{ $uchan } .= $flag;
+                      $self->STATE()->{Chans}->{ $uchan }->{Nicks}->{ $arg } = $self->STATE()->{Nicks}->{ $arg }->{CHANS}->{ $uchan };
                 }
                 last SWITCH;
           }
           if ( $mode =~ /-([$statmodes])/ ) {
                 my $flag = $1;
 		$arg = u_irc $arg, $mapping;
-                if ($self->{STATE}->{Nicks}->{ $arg }->{CHANS}->{ $uchan } =~ /$flag/) {
-                      $self->{STATE}->{Nicks}->{ $arg }->{CHANS}->{ $uchan } =~ s/$flag//;
-                      $self->{STATE}->{Chans}->{ $uchan }->{Nicks}->{ $arg } = $self->{STATE}->{Nicks}->{ $arg }->{CHANS}->{ $uchan };
+                if ($self->STATE()->{Nicks}->{ $arg }->{CHANS}->{ $uchan } =~ /$flag/) {
+                      $self->STATE()->{Nicks}->{ $arg }->{CHANS}->{ $uchan } =~ s/$flag//;
+                      $self->STATE()->{Chans}->{ $uchan }->{Nicks}->{ $arg } = $self->STATE()->{Nicks}->{ $arg }->{CHANS}->{ $uchan };
                 }
                 last SWITCH;
           }
           if ( $mode =~ /\+([$chanmodes->[0]])/ ) {
                 my $flag = $1;
-                $self->{STATE}->{Chans}->{ $uchan }->{Lists}->{ $flag }->{ $arg } = { SetBy => $who, SetAt => time() };
+                $self->STATE()->{Chans}->{ $uchan }->{Lists}->{ $flag }->{ $arg } = { SetBy => $who, SetAt => time() };
                 last SWITCH;
           }
           if ( $mode =~ /-([$chanmodes->[0]])/ ) {
                 my $flag = $1;
-                delete $self->{STATE}->{Chans}->{ $uchan }->{Lists}->{ $flag }->{ $arg };
+                delete $self->STATE()->{Chans}->{ $uchan }->{Lists}->{ $flag }->{ $arg };
                 last SWITCH;
           }
 
           # All unhandled modes with arguments
           if ( $mode =~ /\+([^$chanmodes->[3]])/ ) {
                 my $flag = $1;
-                $self->{STATE}->{Chans}->{ $uchan }->{Mode} .= $flag unless $self->{STATE}->{Chans}->{ $uchan }->{Mode} =~ /$flag/;
-                $self->{STATE}->{Chans}->{ $uchan }->{ModeArgs}->{ $flag } = $arg;
+                $self->STATE()->{Chans}->{ $uchan }->{Mode} .= $flag unless $self->STATE()->{Chans}->{ $uchan }->{Mode} =~ /$flag/;
+                $self->STATE()->{Chans}->{ $uchan }->{ModeArgs}->{ $flag } = $arg;
                 last SWITCH;
           }
           if ( $mode =~ /-([^$chanmodes->[3]])/ ) {
                 my $flag = $1;
-                $self->{STATE}->{Chans}->{ $uchan }->{Mode} =~ s/$flag//;
-                delete $self->{STATE}->{Chans}->{ $uchan }->{ModeArgs}->{ $flag };
+                $self->STATE()->{Chans}->{ $uchan }->{Mode} =~ s/$flag//;
+                delete $self->STATE()->{Chans}->{ $uchan }->{ModeArgs}->{ $flag };
                 last SWITCH;
           }
 
           # Anything else doesn't have arguments so just adjust {Mode} as necessary.
           if ( $mode =~ /^\+(.)/ ) {
                 my $flag = $1;
-                $self->{STATE}->{Chans}->{ $uchan }->{Mode} .= $flag unless $self->{STATE}->{Chans}->{ $uchan }->{Mode} =~ /$flag/;
+                $self->STATE()->{Chans}->{ $uchan }->{Mode} .= $flag unless $self->STATE()->{Chans}->{ $uchan }->{Mode} =~ /$flag/;
                 last SWITCH;
           }
           if ( $mode =~ /^-(.)/ ) {
                 my $flag = $1;
-                if ($self->{STATE}->{Chans}->{ $uchan }->{Mode} =~ /$flag/) {
-                      $self->{STATE}->{Chans}->{ $uchan }->{Mode} =~ s/$flag//;
+                if ($self->STATE()->{Chans}->{ $uchan }->{Mode} =~ /$flag/) {
+                      $self->STATE()->{Chans}->{ $uchan }->{Mode} =~ s/$flag//;
                 }
                 last SWITCH;
           }
         }
      }
      # Lets make the channel mode nice
-     if ( $self->{STATE}->{Chans}->{ $uchan }->{Mode} ) {
-        $self->{STATE}->{Chans}->{ $uchan }->{Mode} = join('', sort {uc $a cmp uc $b} ( split( //, $self->{STATE}->{Chans}->{ $uchan }->{Mode} ) ) );
+     if ( $self->STATE()->{Chans}->{ $uchan }->{Mode} ) {
+        $self->STATE()->{Chans}->{ $uchan }->{Mode} = join('', sort {uc $a cmp uc $b} ( split( //, $self->STATE()->{Chans}->{ $uchan }->{Mode} ) ) );
      } else {
-        delete $self->{STATE}->{Chans}->{ $uchan }->{Mode};
+        delete $self->STATE()->{Chans}->{ $uchan }->{Mode};
      }
   }
   return PCI_EAT_NONE;
 }
 
-sub S_topic {
+sub S_topic :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   my $who = ${ $_[0] };
@@ -319,13 +342,13 @@
   my $uchan = u_irc $channel, $mapping;
   my $topic = ${ $_[2] };
 
-  $self->{STATE}->{Chans}->{ $uchan }->{Topic} = { Value => $topic, SetBy => $who, SetAt => time() };
+  $self->STATE()->{Chans}->{ $uchan }->{Topic} = { Value => $topic, SetBy => $who, SetAt => time() };
 
   return PCI_EAT_NONE;  
 }
 
 # RPL_WHOREPLY
-sub S_352 {
+sub S_352 :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   my ($channel,$user,$host,$server,$nick,$status,$second) = @{ ${ $_[2] } };
@@ -333,31 +356,31 @@
   my $unick = u_irc $nick, $mapping;
   my $uchan = u_irc $channel, $mapping;
 
-  $self->{STATE}->{Nicks}->{ $unick }->{Nick} = $nick;
-  $self->{STATE}->{Nicks}->{ $unick }->{User} = $user;
-  $self->{STATE}->{Nicks}->{ $unick }->{Host} = $host;
-  $self->{STATE}->{Nicks}->{ $unick }->{Real} = $real;
-  $self->{STATE}->{Nicks}->{ $unick }->{Server} = $server;
+  $self->STATE()->{Nicks}->{ $unick }->{Nick} = $nick;
+  $self->STATE()->{Nicks}->{ $unick }->{User} = $user;
+  $self->STATE()->{Nicks}->{ $unick }->{Host} = $host;
+  $self->STATE()->{Nicks}->{ $unick }->{Real} = $real;
+  $self->STATE()->{Nicks}->{ $unick }->{Server} = $server;
   if ( $channel ne '*' ) {
     my $whatever = '';
-    my $existing = $self->{STATE}->{Nicks}->{ $unick }->{CHANS}->{ $uchan } || '';    
+    my $existing = $self->STATE()->{Nicks}->{ $unick }->{CHANS}->{ $uchan } || '';    
     my $prefix = $irc->isupport('PREFIX') || { 'o', '@', 'v', '+' };
     foreach my $mode ( keys %{ $prefix } ) {
       $whatever .= $mode if ( $status =~ /\Q$prefix->{$mode}/ and $existing !~ /\Q$prefix->{$mode}/ );
     }
     $existing .= $whatever unless $existing and $existing =~ /$whatever/;
-    $self->{STATE}->{Nicks}->{ $unick }->{CHANS}->{ $uchan } = $existing;
-    $self->{STATE}->{Chans}->{ $uchan }->{Nicks}->{ $unick } = $existing;
-    $self->{STATE}->{Chans}->{ $uchan }->{Name} = $channel;
+    $self->STATE()->{Nicks}->{ $unick }->{CHANS}->{ $uchan } = $existing;
+    $self->STATE()->{Chans}->{ $uchan }->{Nicks}->{ $unick } = $existing;
+    $self->STATE()->{Chans}->{ $uchan }->{Name} = $channel;
   }
   if ( $status =~ /\*/ ) {
-    $self->{STATE}->{Nicks}->{ $unick }->{IRCop} = 1;
+    $self->STATE()->{Nicks}->{ $unick }->{IRCop} = 1;
   }
   return PCI_EAT_NONE;
 }
 
 #RPL_ENDOFWHO
-sub S_315 {
+sub S_315 :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   #my $channel = ( split / :/, ${ $_[1] } )[0];
@@ -367,20 +390,20 @@
   # If it begins with #, &, + or ! its a channel apparently. RFC2812.
   if ( $channel =~ /^[\x23\x2B\x21\x26]/ ) {
     if ( $self->_channel_sync($channel, 'WHO') ) {
-	my $rec = delete $self->{CHANNEL_SYNCH}->{ $uchan };
+	my $rec = delete $self->CHANNEL_SYNCH()->{ $uchan };
 	$self->_send_event( 'irc_chan_sync', $channel, time() - $rec->{_time} );
     }
   # Otherwise we assume its a nickname
   } else {
-	my $chan = shift @{ $self->{NICK_SYNCH}->{ $uchan } };
-	delete $self->{NICK_SYNCH}->{ $uchan } unless scalar @{ $self->{NICK_SYNCH}->{ $uchan } };
+	my $chan = shift @{ $self->NICK_SYNCH()->{ $uchan } };
+	delete $self->NICK_SYNCH()->{ $uchan } unless scalar @{ $self->NICK_SYNCH()->{ $uchan } };
 	$self->_send_event( 'irc_nick_sync', $channel, $chan );
   }
   return PCI_EAT_NONE;
 }
 
 # RPL_BANLIST
-sub S_367 {
+sub S_367 :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   #my @args = split / /, ${ $_[1] };
@@ -389,12 +412,12 @@
   my $uchan = u_irc $channel, $mapping;
   my ($mask, $who, $when) = @args;
 
-  $self->{STATE}->{Chans}->{ $uchan }->{Lists}->{b}->{ $mask } = { SetBy => $who, SetAt => $when };
+  $self->STATE()->{Chans}->{ $uchan }->{Lists}->{b}->{ $mask } = { SetBy => $who, SetAt => $when };
   return PCI_EAT_NONE;
 }
 
 # RPL_ENDOFBANLIST
-sub S_368 {
+sub S_368 :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   #my @args = split / /, ${ $_[1] };
@@ -403,14 +426,14 @@
   my $uchan = u_irc $channel, $mapping;
 
   if ( $self->_channel_sync($channel, 'BAN') ) {
-	my $rec = delete $self->{CHANNEL_SYNCH}->{ $uchan };
+	my $rec = delete $self->CHANNEL_SYNCH()->{ $uchan };
 	$self->_send_event( 'irc_chan_sync', $channel, time() - $rec->{_time} );
   }
   return PCI_EAT_NONE;
 }
 
 # RPL_INVITELIST
-sub S_346 {
+sub S_346 :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   #my @args = split / /, ${ $_[1] };
@@ -420,12 +443,12 @@
   my ($mask, $who, $when) = @args;
   my $invex = $irc->isupport('INVEX');
 
-  $self->{STATE}->{Chans}->{ $uchan }->{Lists}->{ $invex }->{ $mask } = { SetBy => $who, SetAt => $when };
+  $self->STATE()->{Chans}->{ $uchan }->{Lists}->{ $invex }->{ $mask } = { SetBy => $who, SetAt => $when };
   return PCI_EAT_NONE;
 }
 
 # RPL_ENDOFINVITELIST
-sub S_347 {
+sub S_347 :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   #my @args = split / /, ${ $_[1] };
@@ -437,7 +460,7 @@
 }
 
 # RPL_EXCEPTLIST
-sub S_348 {
+sub S_348 :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   #my @args = split / /, ${ $_[1] };
@@ -447,12 +470,12 @@
   my ($mask, $who, $when) = @args;
   my $excepts = $irc->isupport('EXCEPTS');
 
-  $self->{STATE}->{Chans}->{ $uchan }->{Lists}->{ $excepts }->{ $mask } = { SetBy => $who, SetAt => $when };
+  $self->STATE()->{Chans}->{ $uchan }->{Lists}->{ $excepts }->{ $mask } = { SetBy => $who, SetAt => $when };
   return PCI_EAT_NONE;
 }
 
 # RPL_ENDOFEXCEPTLIST
-sub S_349 {
+sub S_349 :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   #my @args = split / /, ${ $_[1] };
@@ -464,7 +487,7 @@
 }
 
 # RPL_CHANNELMODEIS
-sub S_324 {
+sub S_324 :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   #my @args = split / /, ${ $_[1] };
@@ -478,38 +501,38 @@
         $mode =~ s/\+//;
         my $arg;
         $arg = shift @{ $parsed_mode->{args} } if $mode =~ /[^$chanmodes->[3]]/; # doesn't match a mode with no args
-	if ( $self->{STATE}->{Chans}->{ $uchan }->{Mode} ) {
-          $self->{STATE}->{Chans}->{ $uchan }->{Mode} .= $mode unless $self->{STATE}->{Chans}->{ $uchan }->{Mode} =~ /$mode/;
+	if ( $self->STATE()->{Chans}->{ $uchan }->{Mode} ) {
+          $self->STATE()->{Chans}->{ $uchan }->{Mode} .= $mode unless $self->STATE()->{Chans}->{ $uchan }->{Mode} =~ /$mode/;
 	} else {
-	  $self->{STATE}->{Chans}->{ $uchan }->{Mode} = $mode;
+	  $self->STATE()->{Chans}->{ $uchan }->{Mode} = $mode;
 	}
-        $self->{STATE}->{Chans}->{ $uchan }->{ModeArgs}->{ $mode } = $arg if defined ( $arg );
+        $self->STATE()->{Chans}->{ $uchan }->{ModeArgs}->{ $mode } = $arg if defined ( $arg );
   }
-  if ( $self->{STATE}->{Chans}->{ $uchan }->{Mode} ) {
-        $self->{STATE}->{Chans}->{ $uchan }->{Mode} = join('', sort {uc $a cmp uc $b} split //, $self->{STATE}->{Chans}->{ $uchan }->{Mode} );
+  if ( $self->STATE()->{Chans}->{ $uchan }->{Mode} ) {
+        $self->STATE()->{Chans}->{ $uchan }->{Mode} = join('', sort {uc $a cmp uc $b} split //, $self->STATE()->{Chans}->{ $uchan }->{Mode} );
   }
   if ( $self->_channel_sync($channel, 'MODE') ) {
-	my $rec = delete $self->{CHANNEL_SYNCH}->{ $uchan };
+	my $rec = delete $self->CHANNEL_SYNCH()->{ $uchan };
 	$self->_send_event( 'irc_chan_sync', $channel, time() - $rec->{_time} );
   }
   return PCI_EAT_NONE;
 }
 
 # RPL_TOPIC
-sub S_332 {
+sub S_332 :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   my $channel = ${ $_[2] }->[0];
   my $topic = ${ $_[2] }->[1];
   my $uchan = u_irc $channel, $mapping;
 
-  $self->{STATE}->{Chans}->{ $uchan }->{Topic}->{Value} = $topic;
+  $self->STATE()->{Chans}->{ $uchan }->{Topic}->{Value} = $topic;
 
   return PCI_EAT_NONE;
 }
 
 # RPL_TOPICWHOTIME
-sub S_333 {
+sub S_333 :Cumulative {
   my ($self,$irc) = splice @_, 0, 2;
   my $mapping = $irc->isupport('CASEMAPPING');
   #my @args = split / /, ${ $_[1] };
@@ -517,8 +540,8 @@
   my ($channel, $who, $when) = @args;
   my $uchan = u_irc $channel, $mapping;
 
-  $self->{STATE}->{Chans}->{ $uchan }->{Topic}->{SetBy} = $who;
-  $self->{STATE}->{Chans}->{ $uchan }->{Topic}->{SetAt} = $when;
+  $self->STATE()->{Chans}->{ $uchan }->{Topic}->{SetBy} = $who;
+  $self->STATE()->{Chans}->{ $uchan }->{Topic}->{SetAt} = $when;
 
   return PCI_EAT_NONE;
 }
@@ -527,42 +550,42 @@
 # Internal methods begin with '_'
 #
 
-sub _channel_sync {
+sub _channel_sync :Restricted {
   my $self = shift;
   my $mapping = $self->isupport('CASEMAPPING');
-  my $channel = u_irc $_[0], $mapping || return 0;
+  my $channel = u_irc $_[0], $mapping or return 0;
   my $sync = $_[1];
 
-  return 0 unless $self->_channel_exists($channel) and defined ( $self->{CHANNEL_SYNCH}->{ $channel } );
+  return 0 unless $self->_channel_exists($channel) and defined ( $self->CHANNEL_SYNCH()->{ $channel } );
 
-  $self->{CHANNEL_SYNCH}->{ $channel }->{ $sync } = 1 if $sync;
+  $self->CHANNEL_SYNCH()->{ $channel }->{ $sync } = 1 if $sync;
 
   foreach my $item ( qw(BAN MODE WHO) ) {
-	return 0 unless $self->{CHANNEL_SYNCH}->{ $channel }->{ $item };
+	return 0 unless $self->CHANNEL_SYNCH()->{ $channel }->{ $item };
   }
 
   return 1;
 }
 
-sub _nick_exists {
+sub _nick_exists :Restricted {
   my $self = shift;
   my $nick = shift || return;
   my $mapping = $self->isupport('CASEMAPPING');
   $nick = u_irc $nick, $mapping;
-  return 1 if defined $self->{STATE}->{Nicks}->{ $nick };
+  return 1 if defined $self->STATE()->{Nicks}->{ $nick };
   return 0;
 }
 
-sub _channel_exists {
+sub _channel_exists :Restricted {
   my $self = shift;
   my $channel = shift || return;
   my $mapping = $self->isupport('CASEMAPPING');
   $channel = u_irc $channel, $mapping;
-  return 1 if defined $self->{STATE}->{Chans}->{ $channel };
+  return 1 if defined $self->STATE()->{Chans}->{ $channel };
   return 0;
 }
 
-sub _nick_has_channel_mode {
+sub _nick_has_channel_mode :Restricted {
   my $self = shift;
   my $channel = shift || return;
   my $nick = shift || return;
@@ -573,7 +596,7 @@
   $flag = ( split //, $flag )[0];
 
   return 0 unless $self->is_channel_member($channel,$nick);
-  return 1 if $self->{STATE}->{Nicks}->{ $nick }->{CHANS}->{ $channel } =~ /$flag/;
+  return 1 if $self->STATE()->{Nicks}->{ $nick }->{CHANS}->{ $channel } =~ /$flag/;
   return 0;
 }
 
@@ -582,11 +605,11 @@
   my $self = shift;
   my $mapping = $self->isupport('CASEMAPPING');
   my %result;
-  my $realnick = u_irc $self->{RealNick}, $mapping;
+  my $realnick = u_irc $self->RealNick(), $mapping;
 
   if ( $self->_nick_exists($realnick) ) {
-	foreach my $channel ( keys %{ $self->{STATE}->{Nicks}->{ $realnick }->{CHANS} } ) {
-	  $result{ $self->{STATE}->{Chans}->{ $channel }->{Name} } = $self->{STATE}->{Nicks}->{ $realnick }->{CHANS}->{ $channel };
+	foreach my $channel ( keys %{ $self->STATE()->{Nicks}->{ $realnick }->{CHANS} } ) {
+	  $result{ $self->STATE()->{Chans}->{ $channel }->{Name} } = $self->STATE()->{Nicks}->{ $realnick }->{CHANS}->{ $channel };
 	}
   }
   return \%result;
@@ -594,7 +617,7 @@
 
 sub nicks {
   my $self = shift;
-  return map { $self->{STATE}->{Nicks}->{$_}->{Nick} } keys %{ $self->{STATE}->{Nicks} };
+  return map { $self->STATE()->{Nicks}->{$_}->{Nick} } keys %{ $self->STATE()->{Nicks} };
 }
 
 sub nick_info {
@@ -604,7 +627,7 @@
 
   return unless $self->_nick_exists($nick);
 
-  my $record = $self->{STATE}->{Nicks}->{ $nick };
+  my $record = $self->STATE()->{Nicks}->{ $nick };
   my %result = %{ $record };
   $result{Userhost} = $result{User} . '@' . $result{Host};
   delete $result{'CHANS'};
@@ -618,7 +641,7 @@
 
   return unless $self->_nick_exists($nick);
 
-  my $record = $self->{STATE}->{Nicks}->{ $nick };
+  my $record = $self->STATE()->{Nicks}->{ $nick };
 
   return $record->{Nick} . '!' . $record->{User} . '@' . $record->{Host};
 }
@@ -630,7 +653,7 @@
   my @result;
 
   return unless $self->_nick_exists($nick);
-  return map { $self->{STATE}->{Chans}->{$_}->{Name} } keys %{ $self->{STATE}->{Nicks}->{ $nick }->{CHANS} };
+  return map { $self->STATE()->{Chans}->{$_}->{Name} } keys %{ $self->STATE()->{Nicks}->{ $nick }->{CHANS} };
 }
 
 sub channel_list {
@@ -640,7 +663,7 @@
   my @result;
 
   return unless $self->_channel_exists($channel);
-  return map { $self->{STATE}->{Nicks}->{$_}->{Nick} } keys %{ $self->{STATE}->{Chans}->{ $channel }->{Nicks} };
+  return map { $self->STATE()->{Nicks}->{$_}->{Nick} } keys %{ $self->STATE()->{Chans}->{ $channel }->{Nicks} };
 }
 
 sub is_operator {
@@ -648,7 +671,7 @@
   my $mapping = $self->isupport('CASEMAPPING');
   my $nick = u_irc $_[0], $mapping || return;
   return unless $self->_nick_exists($nick);
-  return 1 if $self->{STATE}->{Nicks}->{ $nick }->{IRCop};
+  return 1 if $self->STATE()->{Nicks}->{ $nick }->{IRCop};
   return 0;
 }
 
@@ -662,7 +685,7 @@
 
   return unless $self->_channel_exists($channel) or $mode;
 
-  return 1 if defined ( $self->{STATE}->{Chans}->{ $channel }->{Mode} ) and $self->{STATE}->{Chans}->{ $channel }->{Mode} =~ /$mode/;
+  return 1 if defined ( $self->STATE()->{Chans}->{ $channel }->{Mode} ) and $self->STATE()->{Chans}->{ $channel }->{Mode} =~ /$mode/;
   return 0;
 }
 
@@ -673,8 +696,8 @@
 
   return unless $self->_channel_exists($channel);
 
-  if ( $self->is_channel_mode_set($channel,'l') and defined ( $self->{STATE}->{Chans}->{ $channel }->{ModeArgs}->{l} ) ) {
-	return $self->{STATE}->{Chans}->{ $channel }->{ModeArgs}->{l};
+  if ( $self->is_channel_mode_set($channel,'l') and defined ( $self->STATE()->{Chans}->{ $channel }->{ModeArgs}->{l} ) ) {
+	return $self->STATE()->{Chans}->{ $channel }->{ModeArgs}->{l};
   }
   return undef;
 }
@@ -686,8 +709,8 @@
 
   return unless $self->_channel_exists($channel);
 
-  if ( $self->is_channel_mode_set($channel,'k') and defined ( $self->{STATE}->{Chans}->{ $channel }->{ModeArgs}->{k} ) ) {
-	return $self->{STATE}->{Chans}->{ $channel }->{ModeArgs}->{k};
+  if ( $self->is_channel_mode_set($channel,'k') and defined ( $self->STATE()->{Chans}->{ $channel }->{ModeArgs}->{k} ) ) {
+	return $self->STATE()->{Chans}->{ $channel }->{ModeArgs}->{k};
   }
   return undef;
 }
@@ -699,8 +722,8 @@
 
   return unless $self->_channel_exists($channel);
 
-  if ( defined ( $self->{STATE}->{Chans}->{ $channel }->{Mode} ) ) {
-	return $self->{STATE}->{Chans}->{ $channel }->{Mode};
+  if ( defined ( $self->STATE()->{Chans}->{ $channel }->{Mode} ) ) {
+	return $self->STATE()->{Chans}->{ $channel }->{Mode};
   }
   return undef;
 }
@@ -711,7 +734,7 @@
   my $channel = u_irc $_[0], $mapping || return 0;
   my $nick = u_irc $_[1], $mapping || return 0;
   return unless $self->_channel_exists($channel) and $self->_nick_exists($nick);
-  return 1 if defined $self->{STATE}->{Chans}->{ $channel }->{Nicks}->{ $nick };
+  return 1 if defined $self->STATE()->{Chans}->{ $channel }->{Nicks}->{ $nick };
   return 0;
 }
 
@@ -790,8 +813,8 @@
 
   return undef unless $self->_channel_exists($channel);
 
-  if ( defined ( $self->{STATE}->{Chans}->{ $channel }->{Lists}->{b} ) ) {
-    %result = %{ $self->{STATE}->{Chans}->{ $channel }->{Lists}->{b} };
+  if ( defined ( $self->STATE()->{Chans}->{ $channel }->{Lists}->{b} ) ) {
+    %result = %{ $self->STATE()->{Chans}->{ $channel }->{Lists}->{b} };
   }
 
   return \%result;
@@ -806,8 +829,8 @@
 
   return undef unless $self->_channel_exists($channel);
 
-  if ( defined ( $self->{STATE}->{Chans}->{ $channel }->{Lists}->{ $excepts } ) ) {
-    %result = %{ $self->{STATE}->{Chans}->{ $channel }->{Lists}->{ $excepts } };
+  if ( defined ( $self->STATE()->{Chans}->{ $channel }->{Lists}->{ $excepts } ) ) {
+    %result = %{ $self->STATE()->{Chans}->{ $channel }->{Lists}->{ $excepts } };
   }
 
   return \%result;
@@ -822,8 +845,8 @@
 
   return undef unless $self->_channel_exists($channel);
 
-  if ( defined ( $self->{STATE}->{Chans}->{ $channel }->{Lists}->{ $invex } ) ) {
-    %result = %{ $self->{STATE}->{Chans}->{ $channel }->{Lists}->{ $invex } };
+  if ( defined ( $self->STATE()->{Chans}->{ $channel }->{Lists}->{ $invex } ) ) {
+    %result = %{ $self->STATE()->{Chans}->{ $channel }->{Lists}->{ $invex } };
   }
 
   return \%result;
@@ -837,8 +860,8 @@
 
   return undef unless $self->_channel_exists($channel);
 
-  if ( defined ( $self->{STATE}->{Chans}->{ $channel }->{Topic} ) ) {
-    %result = %{ $self->{STATE}->{Chans}->{ $channel }->{Topic} };
+  if ( defined ( $self->STATE()->{Chans}->{ $channel }->{Topic} ) ) {
+    %result = %{ $self->STATE()->{Chans}->{ $channel }->{Topic} };
   }
 
   return \%result;
@@ -852,7 +875,7 @@
 
   return undef unless $self->is_channel_member($channel, $nick);
 
-  return $self->{STATE}->{Nicks}->{ $nick }->{CHANS}->{ $channel };
+  return $self->STATE()->{Nicks}->{ $nick }->{CHANS}->{ $channel };
 }
 
 
